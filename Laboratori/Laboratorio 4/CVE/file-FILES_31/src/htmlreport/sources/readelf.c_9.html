<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>readelf.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com</a>
<a name="ln3">/*</a>
<a name="ln4"> * Copyright (c) Christos Zoulas 2003.</a>
<a name="ln5"> * All Rights Reserved.</a>
<a name="ln6"> * </a>
<a name="ln7"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln8"> * modification, are permitted provided that the following conditions</a>
<a name="ln9"> * are met:</a>
<a name="ln10"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln11"> *    notice immediately at the beginning of the file, without modification,</a>
<a name="ln12"> *    this list of conditions, and the following disclaimer.</a>
<a name="ln13"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln14"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln15"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln16"> *  </a>
<a name="ln17"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln18"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln19"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln20"> * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR</a>
<a name="ln21"> * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln22"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln23"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln24"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln25"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln26"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln27"> * SUCH DAMAGE.</a>
<a name="ln28"> */</a>
<a name="ln29">#include &quot;file.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#ifndef lint</a>
<a name="ln32">FILE_RCSID(&quot;@(#)$File: readelf.c,v 1.136 2017/03/29 19:09:52 christos Exp $&quot;)</a>
<a name="ln33">#endif</a>
<a name="ln34"> </a>
<a name="ln35">#ifdef BUILTIN_ELF</a>
<a name="ln36">#include &lt;string.h&gt;</a>
<a name="ln37">#include &lt;ctype.h&gt;</a>
<a name="ln38">#include &lt;stdlib.h&gt;</a>
<a name="ln39">#ifdef HAVE_UNISTD_H</a>
<a name="ln40">#include &lt;unistd.h&gt;</a>
<a name="ln41">#endif</a>
<a name="ln42"> </a>
<a name="ln43">#include &quot;readelf.h&quot;</a>
<a name="ln44">#include &quot;magic.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">#ifdef	ELFCORE</a>
<a name="ln47">private int dophn_core(struct magic_set *, int, int, int, off_t, int, size_t,</a>
<a name="ln48">    off_t, int *, uint16_t *);</a>
<a name="ln49">#endif</a>
<a name="ln50">private int dophn_exec(struct magic_set *, int, int, int, off_t, int, size_t,</a>
<a name="ln51">    off_t, int, int *, uint16_t *);</a>
<a name="ln52">private int doshn(struct magic_set *, int, int, int, off_t, int, size_t,</a>
<a name="ln53">    off_t, int, int, int *, uint16_t *);</a>
<a name="ln54">private size_t donote(struct magic_set *, void *, size_t, size_t, int,</a>
<a name="ln55">    int, size_t, int *, uint16_t *, int, off_t, int, off_t);</a>
<a name="ln56"> </a>
<a name="ln57">#define	ELF_ALIGN(a)	((((a) + align - 1) / align) * align)</a>
<a name="ln58"> </a>
<a name="ln59">#define isquote(c) (strchr(&quot;'\&quot;`&quot;, (c)) != NULL)</a>
<a name="ln60"> </a>
<a name="ln61">private uint16_t getu16(int, uint16_t);</a>
<a name="ln62">private uint32_t getu32(int, uint32_t);</a>
<a name="ln63">private uint64_t getu64(int, uint64_t);</a>
<a name="ln64"> </a>
<a name="ln65">#define MAX_PHNUM	128</a>
<a name="ln66">#define	MAX_SHNUM	32768</a>
<a name="ln67">#define SIZE_UNKNOWN	((off_t)-1)</a>
<a name="ln68"> </a>
<a name="ln69">private int</a>
<a name="ln70">toomany(struct magic_set *ms, const char *name, uint16_t num)</a>
<a name="ln71">{</a>
<a name="ln72">	if (file_printf(ms, &quot;, too many %s (%u)&quot;, name, num</a>
<a name="ln73">	    ) == -1)</a>
<a name="ln74">		return -1;</a>
<a name="ln75">	return 0;</a>
<a name="ln76">}</a>
<a name="ln77"> </a>
<a name="ln78">private uint16_t</a>
<a name="ln79">getu16(int swap, uint16_t value)</a>
<a name="ln80">{</a>
<a name="ln81">	union {</a>
<a name="ln82">		uint16_t ui;</a>
<a name="ln83">		char c[2];</a>
<a name="ln84">	} retval, tmpval;</a>
<a name="ln85"> </a>
<a name="ln86">	if (swap) {</a>
<a name="ln87">		tmpval.ui = value;</a>
<a name="ln88"> </a>
<a name="ln89">		retval.c[0] = tmpval.c[1];</a>
<a name="ln90">		retval.c[1] = tmpval.c[0];</a>
<a name="ln91">		</a>
<a name="ln92">		return retval.ui;</a>
<a name="ln93">	} else</a>
<a name="ln94">		return value;</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">private uint32_t</a>
<a name="ln98">getu32(int swap, uint32_t value)</a>
<a name="ln99">{</a>
<a name="ln100">	union {</a>
<a name="ln101">		uint32_t ui;</a>
<a name="ln102">		char c[4];</a>
<a name="ln103">	} retval, tmpval;</a>
<a name="ln104"> </a>
<a name="ln105">	if (swap) {</a>
<a name="ln106">		tmpval.ui = value;</a>
<a name="ln107"> </a>
<a name="ln108">		retval.c[0] = tmpval.c[3];</a>
<a name="ln109">		retval.c[1] = tmpval.c[2];</a>
<a name="ln110">		retval.c[2] = tmpval.c[1];</a>
<a name="ln111">		retval.c[3] = tmpval.c[0];</a>
<a name="ln112">		</a>
<a name="ln113">		return retval.ui;</a>
<a name="ln114">	} else</a>
<a name="ln115">		return value;</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118">private uint64_t</a>
<a name="ln119">getu64(int swap, uint64_t value)</a>
<a name="ln120">{</a>
<a name="ln121">	union {</a>
<a name="ln122">		uint64_t ui;</a>
<a name="ln123">		char c[8];</a>
<a name="ln124">	} retval, tmpval;</a>
<a name="ln125"> </a>
<a name="ln126">	if (swap) {</a>
<a name="ln127">		tmpval.ui = value;</a>
<a name="ln128"> </a>
<a name="ln129">		retval.c[0] = tmpval.c[7];</a>
<a name="ln130">		retval.c[1] = tmpval.c[6];</a>
<a name="ln131">		retval.c[2] = tmpval.c[5];</a>
<a name="ln132">		retval.c[3] = tmpval.c[4];</a>
<a name="ln133">		retval.c[4] = tmpval.c[3];</a>
<a name="ln134">		retval.c[5] = tmpval.c[2];</a>
<a name="ln135">		retval.c[6] = tmpval.c[1];</a>
<a name="ln136">		retval.c[7] = tmpval.c[0];</a>
<a name="ln137">		</a>
<a name="ln138">		return retval.ui;</a>
<a name="ln139">	} else</a>
<a name="ln140">		return value;</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">#define elf_getu16(swap, value) getu16(swap, value)</a>
<a name="ln144">#define elf_getu32(swap, value) getu32(swap, value)</a>
<a name="ln145">#define elf_getu64(swap, value) getu64(swap, value)</a>
<a name="ln146"> </a>
<a name="ln147">#define xsh_addr	(clazz == ELFCLASS32			\</a>
<a name="ln148">			 ? (void *)&amp;sh32			\</a>
<a name="ln149">			 : (void *)&amp;sh64)</a>
<a name="ln150">#define xsh_sizeof	(clazz == ELFCLASS32			\</a>
<a name="ln151">			 ? sizeof(sh32)				\</a>
<a name="ln152">			 : sizeof(sh64))</a>
<a name="ln153">#define xsh_size	(size_t)(clazz == ELFCLASS32		\</a>
<a name="ln154">			 ? elf_getu32(swap, sh32.sh_size)	\</a>
<a name="ln155">			 : elf_getu64(swap, sh64.sh_size))</a>
<a name="ln156">#define xsh_offset	(off_t)(clazz == ELFCLASS32		\</a>
<a name="ln157">			 ? elf_getu32(swap, sh32.sh_offset)	\</a>
<a name="ln158">			 : elf_getu64(swap, sh64.sh_offset))</a>
<a name="ln159">#define xsh_type	(clazz == ELFCLASS32			\</a>
<a name="ln160">			 ? elf_getu32(swap, sh32.sh_type)	\</a>
<a name="ln161">			 : elf_getu32(swap, sh64.sh_type))</a>
<a name="ln162">#define xsh_name    	(clazz == ELFCLASS32			\</a>
<a name="ln163">			 ? elf_getu32(swap, sh32.sh_name)	\</a>
<a name="ln164">			 : elf_getu32(swap, sh64.sh_name))</a>
<a name="ln165">#define xph_addr	(clazz == ELFCLASS32			\</a>
<a name="ln166">			 ? (void *) &amp;ph32			\</a>
<a name="ln167">			 : (void *) &amp;ph64)</a>
<a name="ln168">#define xph_sizeof	(clazz == ELFCLASS32			\</a>
<a name="ln169">			 ? sizeof(ph32)				\</a>
<a name="ln170">			 : sizeof(ph64))</a>
<a name="ln171">#define xph_type	(clazz == ELFCLASS32			\</a>
<a name="ln172">			 ? elf_getu32(swap, ph32.p_type)	\</a>
<a name="ln173">			 : elf_getu32(swap, ph64.p_type))</a>
<a name="ln174">#define xph_offset	(off_t)(clazz == ELFCLASS32		\</a>
<a name="ln175">			 ? elf_getu32(swap, ph32.p_offset)	\</a>
<a name="ln176">			 : elf_getu64(swap, ph64.p_offset))</a>
<a name="ln177">#define xph_align	(size_t)((clazz == ELFCLASS32		\</a>
<a name="ln178">			 ? (off_t) (ph32.p_align ? 		\</a>
<a name="ln179">			    elf_getu32(swap, ph32.p_align) : 4) \</a>
<a name="ln180">			 : (off_t) (ph64.p_align ?		\</a>
<a name="ln181">			    elf_getu64(swap, ph64.p_align) : 4)))</a>
<a name="ln182">#define xph_vaddr	(size_t)((clazz == ELFCLASS32		\</a>
<a name="ln183">			 ? (off_t) (ph32.p_vaddr ? 		\</a>
<a name="ln184">			    elf_getu32(swap, ph32.p_vaddr) : 4) \</a>
<a name="ln185">			 : (off_t) (ph64.p_vaddr ?		\</a>
<a name="ln186">			    elf_getu64(swap, ph64.p_vaddr) : 4)))</a>
<a name="ln187">#define xph_filesz	(size_t)((clazz == ELFCLASS32		\</a>
<a name="ln188">			 ? elf_getu32(swap, ph32.p_filesz)	\</a>
<a name="ln189">			 : elf_getu64(swap, ph64.p_filesz)))</a>
<a name="ln190">#define xnh_addr	(clazz == ELFCLASS32			\</a>
<a name="ln191">			 ? (void *)&amp;nh32			\</a>
<a name="ln192">			 : (void *)&amp;nh64)</a>
<a name="ln193">#define xph_memsz	(size_t)((clazz == ELFCLASS32		\</a>
<a name="ln194">			 ? elf_getu32(swap, ph32.p_memsz)	\</a>
<a name="ln195">			 : elf_getu64(swap, ph64.p_memsz)))</a>
<a name="ln196">#define xnh_sizeof	(clazz == ELFCLASS32			\</a>
<a name="ln197">			 ? sizeof(nh32)				\</a>
<a name="ln198">			 : sizeof(nh64))</a>
<a name="ln199">#define xnh_type	(clazz == ELFCLASS32			\</a>
<a name="ln200">			 ? elf_getu32(swap, nh32.n_type)	\</a>
<a name="ln201">			 : elf_getu32(swap, nh64.n_type))</a>
<a name="ln202">#define xnh_namesz	(clazz == ELFCLASS32			\</a>
<a name="ln203">			 ? elf_getu32(swap, nh32.n_namesz)	\</a>
<a name="ln204">			 : elf_getu32(swap, nh64.n_namesz))</a>
<a name="ln205">#define xnh_descsz	(clazz == ELFCLASS32			\</a>
<a name="ln206">			 ? elf_getu32(swap, nh32.n_descsz)	\</a>
<a name="ln207">			 : elf_getu32(swap, nh64.n_descsz))</a>
<a name="ln208">#define prpsoffsets(i)	(clazz == ELFCLASS32			\</a>
<a name="ln209">			 ? prpsoffsets32[i]			\</a>
<a name="ln210">			 : prpsoffsets64[i])</a>
<a name="ln211">#define xcap_addr	(clazz == ELFCLASS32			\</a>
<a name="ln212">			 ? (void *)&amp;cap32			\</a>
<a name="ln213">			 : (void *)&amp;cap64)</a>
<a name="ln214">#define xcap_sizeof	(clazz == ELFCLASS32			\</a>
<a name="ln215">			 ? sizeof cap32				\</a>
<a name="ln216">			 : sizeof cap64)</a>
<a name="ln217">#define xcap_tag	(clazz == ELFCLASS32			\</a>
<a name="ln218">			 ? elf_getu32(swap, cap32.c_tag)	\</a>
<a name="ln219">			 : elf_getu64(swap, cap64.c_tag))</a>
<a name="ln220">#define xcap_val	(clazz == ELFCLASS32			\</a>
<a name="ln221">			 ? elf_getu32(swap, cap32.c_un.c_val)	\</a>
<a name="ln222">			 : elf_getu64(swap, cap64.c_un.c_val))</a>
<a name="ln223">#define xauxv_addr	(clazz == ELFCLASS32			\</a>
<a name="ln224">			 ? (void *)&amp;auxv32			\</a>
<a name="ln225">			 : (void *)&amp;auxv64)</a>
<a name="ln226">#define xauxv_sizeof	(clazz == ELFCLASS32			\</a>
<a name="ln227">			 ? sizeof(auxv32)			\</a>
<a name="ln228">			 : sizeof(auxv64))</a>
<a name="ln229">#define xauxv_type	(clazz == ELFCLASS32			\</a>
<a name="ln230">			 ? elf_getu32(swap, auxv32.a_type)	\</a>
<a name="ln231">			 : elf_getu64(swap, auxv64.a_type))</a>
<a name="ln232">#define xauxv_val	(clazz == ELFCLASS32			\</a>
<a name="ln233">			 ? elf_getu32(swap, auxv32.a_v)		\</a>
<a name="ln234">			 : elf_getu64(swap, auxv64.a_v))</a>
<a name="ln235"> </a>
<a name="ln236">#ifdef ELFCORE</a>
<a name="ln237">/*</a>
<a name="ln238"> * Try larger offsets first to avoid false matches</a>
<a name="ln239"> * from earlier data that happen to look like strings.</a>
<a name="ln240"> */</a>
<a name="ln241">static const size_t	prpsoffsets32[] = {</a>
<a name="ln242">#ifdef USE_NT_PSINFO</a>
<a name="ln243">	104,		/* SunOS 5.x (command line) */</a>
<a name="ln244">	88,		/* SunOS 5.x (short name) */</a>
<a name="ln245">#endif /* USE_NT_PSINFO */</a>
<a name="ln246"> </a>
<a name="ln247">	100,		/* SunOS 5.x (command line) */</a>
<a name="ln248">	84,		/* SunOS 5.x (short name) */</a>
<a name="ln249"> </a>
<a name="ln250">	44,		/* Linux (command line) */</a>
<a name="ln251">	28,		/* Linux 2.0.36 (short name) */</a>
<a name="ln252"> </a>
<a name="ln253">	8,		/* FreeBSD */</a>
<a name="ln254">};</a>
<a name="ln255"> </a>
<a name="ln256">static const size_t	prpsoffsets64[] = {</a>
<a name="ln257">#ifdef USE_NT_PSINFO</a>
<a name="ln258">	152,		/* SunOS 5.x (command line) */</a>
<a name="ln259">	136,		/* SunOS 5.x (short name) */</a>
<a name="ln260">#endif /* USE_NT_PSINFO */</a>
<a name="ln261"> </a>
<a name="ln262">	136,		/* SunOS 5.x, 64-bit (command line) */</a>
<a name="ln263">	120,		/* SunOS 5.x, 64-bit (short name) */</a>
<a name="ln264"> </a>
<a name="ln265">	56,		/* Linux (command line) */</a>
<a name="ln266">	40,             /* Linux (tested on core from 2.4.x, short name) */</a>
<a name="ln267"> </a>
<a name="ln268">	16,		/* FreeBSD, 64-bit */</a>
<a name="ln269">};</a>
<a name="ln270"> </a>
<a name="ln271">#define	NOFFSETS32	(sizeof prpsoffsets32 / sizeof prpsoffsets32[0])</a>
<a name="ln272">#define NOFFSETS64	(sizeof prpsoffsets64 / sizeof prpsoffsets64[0])</a>
<a name="ln273"> </a>
<a name="ln274">#define NOFFSETS	(clazz == ELFCLASS32 ? NOFFSETS32 : NOFFSETS64)</a>
<a name="ln275"> </a>
<a name="ln276">/*</a>
<a name="ln277"> * Look through the program headers of an executable image, searching</a>
<a name="ln278"> * for a PT_NOTE section of type NT_PRPSINFO, with a name &quot;CORE&quot; or</a>
<a name="ln279"> * &quot;FreeBSD&quot;; if one is found, try looking in various places in its</a>
<a name="ln280"> * contents for a 16-character string containing only printable</a>
<a name="ln281"> * characters - if found, that string should be the name of the program</a>
<a name="ln282"> * that dropped core.  Note: right after that 16-character string is,</a>
<a name="ln283"> * at least in SunOS 5.x (and possibly other SVR4-flavored systems) and</a>
<a name="ln284"> * Linux, a longer string (80 characters, in 5.x, probably other</a>
<a name="ln285"> * SVR4-flavored systems, and Linux) containing the start of the</a>
<a name="ln286"> * command line for that program.</a>
<a name="ln287"> *</a>
<a name="ln288"> * SunOS 5.x core files contain two PT_NOTE sections, with the types</a>
<a name="ln289"> * NT_PRPSINFO (old) and NT_PSINFO (new).  These structs contain the</a>
<a name="ln290"> * same info about the command name and command line, so it probably</a>
<a name="ln291"> * isn't worthwhile to look for NT_PSINFO, but the offsets are provided</a>
<a name="ln292"> * above (see USE_NT_PSINFO), in case we ever decide to do so.  The</a>
<a name="ln293"> * NT_PRPSINFO and NT_PSINFO sections are always in order and adjacent;</a>
<a name="ln294"> * the SunOS 5.x file command relies on this (and prefers the latter).</a>
<a name="ln295"> *</a>
<a name="ln296"> * The signal number probably appears in a section of type NT_PRSTATUS,</a>
<a name="ln297"> * but that's also rather OS-dependent, in ways that are harder to</a>
<a name="ln298"> * dissect with heuristics, so I'm not bothering with the signal number.</a>
<a name="ln299"> * (I suppose the signal number could be of interest in situations where</a>
<a name="ln300"> * you don't have the binary of the program that dropped core; if you</a>
<a name="ln301"> * *do* have that binary, the debugger will probably tell you what</a>
<a name="ln302"> * signal it was.)</a>
<a name="ln303"> */</a>
<a name="ln304"> </a>
<a name="ln305">#define	OS_STYLE_SVR4		0</a>
<a name="ln306">#define	OS_STYLE_FREEBSD	1</a>
<a name="ln307">#define	OS_STYLE_NETBSD		2</a>
<a name="ln308"> </a>
<a name="ln309">private const char os_style_names[][8] = {</a>
<a name="ln310">	&quot;SVR4&quot;,</a>
<a name="ln311">	&quot;FreeBSD&quot;,</a>
<a name="ln312">	&quot;NetBSD&quot;,</a>
<a name="ln313">};</a>
<a name="ln314"> </a>
<a name="ln315">#define FLAGS_CORE_STYLE		0x003</a>
<a name="ln316"> </a>
<a name="ln317">#define FLAGS_DID_CORE			0x004</a>
<a name="ln318">#define FLAGS_DID_OS_NOTE		0x008</a>
<a name="ln319">#define FLAGS_DID_BUILD_ID		0x010</a>
<a name="ln320">#define FLAGS_DID_CORE_STYLE		0x020</a>
<a name="ln321">#define FLAGS_DID_NETBSD_PAX		0x040</a>
<a name="ln322">#define FLAGS_DID_NETBSD_MARCH		0x080</a>
<a name="ln323">#define FLAGS_DID_NETBSD_CMODEL		0x100</a>
<a name="ln324">#define FLAGS_DID_NETBSD_UNKNOWN	0x200</a>
<a name="ln325">#define FLAGS_IS_CORE			0x400</a>
<a name="ln326">#define FLAGS_DID_AUXV			0x800</a>
<a name="ln327"> </a>
<a name="ln328">private int</a>
<a name="ln329">dophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,</a>
<a name="ln330">    int num, size_t size, off_t fsize, int *flags, uint16_t *notecount)</a>
<a name="ln331">{</a>
<a name="ln332">	Elf32_Phdr ph32;</a>
<a name="ln333">	Elf64_Phdr ph64;</a>
<a name="ln334">	size_t offset, len;</a>
<a name="ln335">	unsigned char nbuf[BUFSIZ];</a>
<a name="ln336">	ssize_t bufsize;</a>
<a name="ln337">	off_t ph_off = off;</a>
<a name="ln338">	int ph_num = num;</a>
<a name="ln339"> </a>
<a name="ln340">	if (size != xph_sizeof) {</a>
<a name="ln341">		if (file_printf(ms, &quot;, corrupted program header size&quot;) == -1)</a>
<a name="ln342">			return -1;</a>
<a name="ln343">		return 0;</a>
<a name="ln344">	}</a>
<a name="ln345"> </a>
<a name="ln346">	/*</a>
<a name="ln347">	 * Loop through all the program headers.</a>
<a name="ln348">	 */</a>
<a name="ln349">	for ( ; num; num--) {</a>
<a name="ln350">		if (pread(fd, xph_addr, xph_sizeof, off) &lt; (ssize_t)xph_sizeof) {</a>
<a name="ln351">			file_badread(ms);</a>
<a name="ln352">			return -1;</a>
<a name="ln353">		}</a>
<a name="ln354">		off += size;</a>
<a name="ln355"> </a>
<a name="ln356">		if (fsize != SIZE_UNKNOWN &amp;&amp; xph_offset &gt; fsize) {</a>
<a name="ln357">			/* Perhaps warn here */</a>
<a name="ln358">			continue;</a>
<a name="ln359">		}</a>
<a name="ln360"> </a>
<a name="ln361">		if (xph_type != PT_NOTE)</a>
<a name="ln362">			continue;</a>
<a name="ln363"> </a>
<a name="ln364">		/*</a>
<a name="ln365">		 * This is a PT_NOTE section; loop through all the notes</a>
<a name="ln366">		 * in the section.</a>
<a name="ln367">		 */</a>
<a name="ln368">		len = xph_filesz &lt; sizeof(nbuf) ? xph_filesz : sizeof(nbuf);</a>
<a name="ln369">		if ((bufsize = pread(fd, nbuf, len, xph_offset)) == -1) {</a>
<a name="ln370">			file_badread(ms);</a>
<a name="ln371">			return -1;</a>
<a name="ln372">		}</a>
<a name="ln373">		offset = 0;</a>
<a name="ln374">		for (;;) {</a>
<a name="ln375">			if (offset &gt;= (size_t)bufsize)</a>
<a name="ln376">				break;</a>
<a name="ln377">			offset = donote(ms, nbuf, offset, (size_t)bufsize,</a>
<a name="ln378">			    clazz, swap, 4, flags, notecount, fd, ph_off,</a>
<a name="ln379">			    ph_num, fsize);</a>
<a name="ln380">			if (offset == 0)</a>
<a name="ln381">				break;</a>
<a name="ln382"> </a>
<a name="ln383">		}</a>
<a name="ln384">	}</a>
<a name="ln385">	return 0;</a>
<a name="ln386">}</a>
<a name="ln387">#endif</a>
<a name="ln388"> </a>
<a name="ln389">static void</a>
<a name="ln390">do_note_netbsd_version(struct magic_set *ms, int swap, void *v)</a>
<a name="ln391">{</a>
<a name="ln392">	uint32_t desc;</a>
<a name="ln393">	(void)memcpy(&amp;desc, v, sizeof(desc));</a>
<a name="ln394">	desc = elf_getu32(swap, desc);</a>
<a name="ln395"> </a>
<a name="ln396">	if (file_printf(ms, &quot;, for NetBSD&quot;) == -1)</a>
<a name="ln397">		return;</a>
<a name="ln398">	/*</a>
<a name="ln399">	 * The version number used to be stuck as 199905, and was thus</a>
<a name="ln400">	 * basically content-free.  Newer versions of NetBSD have fixed</a>
<a name="ln401">	 * this and now use the encoding of __NetBSD_Version__:</a>
<a name="ln402">	 *</a>
<a name="ln403">	 *	MMmmrrpp00</a>
<a name="ln404">	 *</a>
<a name="ln405">	 * M = major version</a>
<a name="ln406">	 * m = minor version</a>
<a name="ln407">	 * r = release [&quot;&quot;,A-Z,Z[A-Z] but numeric]</a>
<a name="ln408">	 * p = patchlevel</a>
<a name="ln409">	 */</a>
<a name="ln410">	if (desc &gt; 100000000U) {</a>
<a name="ln411">		uint32_t ver_patch = (desc / 100) % 100;</a>
<a name="ln412">		uint32_t ver_rel = (desc / 10000) % 100;</a>
<a name="ln413">		uint32_t ver_min = (desc / 1000000) % 100;</a>
<a name="ln414">		uint32_t ver_maj = desc / 100000000;</a>
<a name="ln415"> </a>
<a name="ln416">		if (file_printf(ms, &quot; %u.%u&quot;, ver_maj, ver_min) == -1)</a>
<a name="ln417">			return;</a>
<a name="ln418">		if (ver_rel == 0 &amp;&amp; ver_patch != 0) {</a>
<a name="ln419">			if (file_printf(ms, &quot;.%u&quot;, ver_patch) == -1)</a>
<a name="ln420">				return;</a>
<a name="ln421">		} else if (ver_rel != 0) {</a>
<a name="ln422">			while (ver_rel &gt; 26) {</a>
<a name="ln423">				if (file_printf(ms, &quot;Z&quot;) == -1)</a>
<a name="ln424">					return;</a>
<a name="ln425">				ver_rel -= 26;</a>
<a name="ln426">			}</a>
<a name="ln427">			if (file_printf(ms, &quot;%c&quot;, 'A' + ver_rel - 1)</a>
<a name="ln428">			    == -1)</a>
<a name="ln429">				return;</a>
<a name="ln430">		}</a>
<a name="ln431">	}</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">static void</a>
<a name="ln435">do_note_freebsd_version(struct magic_set *ms, int swap, void *v)</a>
<a name="ln436">{</a>
<a name="ln437">	uint32_t desc;</a>
<a name="ln438"> </a>
<a name="ln439">	(void)memcpy(&amp;desc, v, sizeof(desc));</a>
<a name="ln440">	desc = elf_getu32(swap, desc);</a>
<a name="ln441">	if (file_printf(ms, &quot;, for FreeBSD&quot;) == -1)</a>
<a name="ln442">		return;</a>
<a name="ln443"> </a>
<a name="ln444">	/*</a>
<a name="ln445">	 * Contents is __FreeBSD_version, whose relation to OS</a>
<a name="ln446">	 * versions is defined by a huge table in the Porter's</a>
<a name="ln447">	 * Handbook.  This is the general scheme:</a>
<a name="ln448">	 * </a>
<a name="ln449">	 * Releases:</a>
<a name="ln450">	 * 	Mmp000 (before 4.10)</a>
<a name="ln451">	 * 	Mmi0p0 (before 5.0)</a>
<a name="ln452">	 * 	Mmm0p0</a>
<a name="ln453">	 * </a>
<a name="ln454">	 * Development branches:</a>
<a name="ln455">	 * 	Mmpxxx (before 4.6)</a>
<a name="ln456">	 * 	Mmp1xx (before 4.10)</a>
<a name="ln457">	 * 	Mmi1xx (before 5.0)</a>
<a name="ln458">	 * 	M000xx (pre-M.0)</a>
<a name="ln459">	 * 	Mmm1xx</a>
<a name="ln460">	 * </a>
<a name="ln461">	 * M = major version</a>
<a name="ln462">	 * m = minor version</a>
<a name="ln463">	 * i = minor version increment (491000 -&gt; 4.10)</a>
<a name="ln464">	 * p = patchlevel</a>
<a name="ln465">	 * x = revision</a>
<a name="ln466">	 * </a>
<a name="ln467">	 * The first release of FreeBSD to use ELF by default</a>
<a name="ln468">	 * was version 3.0.</a>
<a name="ln469">	 */</a>
<a name="ln470">	if (desc == 460002) {</a>
<a name="ln471">		if (file_printf(ms, &quot; 4.6.2&quot;) == -1)</a>
<a name="ln472">			return;</a>
<a name="ln473">	} else if (desc &lt; 460100) {</a>
<a name="ln474">		if (file_printf(ms, &quot; %d.%d&quot;, desc / 100000,</a>
<a name="ln475">		    desc / 10000 % 10) == -1)</a>
<a name="ln476">			return;</a>
<a name="ln477">		if (desc / 1000 % 10 &gt; 0)</a>
<a name="ln478">			if (file_printf(ms, &quot;.%d&quot;, desc / 1000 % 10) == -1)</a>
<a name="ln479">				return;</a>
<a name="ln480">		if ((desc % 1000 &gt; 0) || (desc % 100000 == 0))</a>
<a name="ln481">			if (file_printf(ms, &quot; (%d)&quot;, desc) == -1)</a>
<a name="ln482">				return;</a>
<a name="ln483">	} else if (desc &lt; 500000) {</a>
<a name="ln484">		if (file_printf(ms, &quot; %d.%d&quot;, desc / 100000,</a>
<a name="ln485">		    desc / 10000 % 10 + desc / 1000 % 10) == -1)</a>
<a name="ln486">			return;</a>
<a name="ln487">		if (desc / 100 % 10 &gt; 0) {</a>
<a name="ln488">			if (file_printf(ms, &quot; (%d)&quot;, desc) == -1)</a>
<a name="ln489">				return;</a>
<a name="ln490">		} else if (desc / 10 % 10 &gt; 0) {</a>
<a name="ln491">			if (file_printf(ms, &quot;.%d&quot;, desc / 10 % 10) == -1)</a>
<a name="ln492">				return;</a>
<a name="ln493">		}</a>
<a name="ln494">	} else {</a>
<a name="ln495">		if (file_printf(ms, &quot; %d.%d&quot;, desc / 100000,</a>
<a name="ln496">		    desc / 1000 % 100) == -1)</a>
<a name="ln497">			return;</a>
<a name="ln498">		if ((desc / 100 % 10 &gt; 0) ||</a>
<a name="ln499">		    (desc % 100000 / 100 == 0)) {</a>
<a name="ln500">			if (file_printf(ms, &quot; (%d)&quot;, desc) == -1)</a>
<a name="ln501">				return;</a>
<a name="ln502">		} else if (desc / 10 % 10 &gt; 0) {</a>
<a name="ln503">			if (file_printf(ms, &quot;.%d&quot;, desc / 10 % 10) == -1)</a>
<a name="ln504">				return;</a>
<a name="ln505">		}</a>
<a name="ln506">	}</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509">private int</a>
<a name="ln510">/*ARGSUSED*/</a>
<a name="ln511">do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,</a>
<a name="ln512">    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,</a>
<a name="ln513">    size_t noff, size_t doff, int *flags)</a>
<a name="ln514">{</a>
<a name="ln515">	if (namesz == 4 &amp;&amp; strcmp((char *)&amp;nbuf[noff], &quot;GNU&quot;) == 0 &amp;&amp;</a>
<a name="ln516">	    type == NT_GNU_BUILD_ID &amp;&amp; (descsz &gt;= 4 || descsz &lt;= 20)) {</a>
<a name="ln517">		uint8_t desc[20];</a>
<a name="ln518">		const char *btype;</a>
<a name="ln519">		uint32_t i;</a>
<a name="ln520">		*flags |= FLAGS_DID_BUILD_ID;</a>
<a name="ln521">		switch (descsz) {</a>
<a name="ln522">		case 8:</a>
<a name="ln523">		    btype = &quot;xxHash&quot;;</a>
<a name="ln524">		    break;</a>
<a name="ln525">		case 16:</a>
<a name="ln526">		    btype = &quot;md5/uuid&quot;;</a>
<a name="ln527">		    break;</a>
<a name="ln528">		case 20:</a>
<a name="ln529">		    btype = &quot;sha1&quot;;</a>
<a name="ln530">		    break;</a>
<a name="ln531">		default:</a>
<a name="ln532">		    btype = &quot;unknown&quot;;</a>
<a name="ln533">		    break;</a>
<a name="ln534">		}</a>
<a name="ln535">		if (file_printf(ms, &quot;, BuildID[%s]=&quot;, btype) == -1)</a>
<a name="ln536">			return 1;</a>
<a name="ln537">		(void)memcpy(desc, &amp;nbuf[doff], descsz);</a>
<a name="ln538">		for (i = 0; i &lt; descsz; i++)</a>
<a name="ln539">		    if (file_printf(ms, &quot;%02x&quot;, desc[i]) == -1)</a>
<a name="ln540">			return 1;</a>
<a name="ln541">		return 1;</a>
<a name="ln542">	}</a>
<a name="ln543">	return 0;</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546">private int</a>
<a name="ln547">do_os_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,</a>
<a name="ln548">    int swap, uint32_t namesz, uint32_t descsz,</a>
<a name="ln549">    size_t noff, size_t doff, int *flags)</a>
<a name="ln550">{</a>
<a name="ln551">	if (namesz == 5 &amp;&amp; strcmp((char *)&amp;nbuf[noff], &quot;SuSE&quot;) == 0 &amp;&amp;</a>
<a name="ln552">	    type == NT_GNU_VERSION &amp;&amp; descsz == 2) {</a>
<a name="ln553">	    *flags |= FLAGS_DID_OS_NOTE;</a>
<a name="ln554">	    file_printf(ms, &quot;, for SuSE %d.%d&quot;, nbuf[doff], nbuf[doff + 1]);</a>
<a name="ln555">	    return 1;</a>
<a name="ln556">	}</a>
<a name="ln557"> </a>
<a name="ln558">	if (namesz == 4 &amp;&amp; strcmp((char *)&amp;nbuf[noff], &quot;GNU&quot;) == 0 &amp;&amp;</a>
<a name="ln559">	    type == NT_GNU_VERSION &amp;&amp; descsz == 16) {</a>
<a name="ln560">		uint32_t desc[4];</a>
<a name="ln561">		(void)memcpy(desc, &amp;nbuf[doff], sizeof(desc));</a>
<a name="ln562"> </a>
<a name="ln563">		*flags |= FLAGS_DID_OS_NOTE;</a>
<a name="ln564">		if (file_printf(ms, &quot;, for GNU/&quot;) == -1)</a>
<a name="ln565">			return 1;</a>
<a name="ln566">		switch (elf_getu32(swap, desc[0])) {</a>
<a name="ln567">		case GNU_OS_LINUX:</a>
<a name="ln568">			if (file_printf(ms, &quot;Linux&quot;) == -1)</a>
<a name="ln569">				return 1;</a>
<a name="ln570">			break;</a>
<a name="ln571">		case GNU_OS_HURD:</a>
<a name="ln572">			if (file_printf(ms, &quot;Hurd&quot;) == -1)</a>
<a name="ln573">				return 1;</a>
<a name="ln574">			break;</a>
<a name="ln575">		case GNU_OS_SOLARIS:</a>
<a name="ln576">			if (file_printf(ms, &quot;Solaris&quot;) == -1)</a>
<a name="ln577">				return 1;</a>
<a name="ln578">			break;</a>
<a name="ln579">		case GNU_OS_KFREEBSD:</a>
<a name="ln580">			if (file_printf(ms, &quot;kFreeBSD&quot;) == -1)</a>
<a name="ln581">				return 1;</a>
<a name="ln582">			break;</a>
<a name="ln583">		case GNU_OS_KNETBSD:</a>
<a name="ln584">			if (file_printf(ms, &quot;kNetBSD&quot;) == -1)</a>
<a name="ln585">				return 1;</a>
<a name="ln586">			break;</a>
<a name="ln587">		default:</a>
<a name="ln588">			if (file_printf(ms, &quot;&lt;unknown&gt;&quot;) == -1)</a>
<a name="ln589">				return 1; </a>
<a name="ln590">		}</a>
<a name="ln591">		if (file_printf(ms, &quot; %d.%d.%d&quot;, elf_getu32(swap, desc[1]),</a>
<a name="ln592">		    elf_getu32(swap, desc[2]), elf_getu32(swap, desc[3])) == -1)</a>
<a name="ln593">			return 1;</a>
<a name="ln594">		return 1;</a>
<a name="ln595">	}</a>
<a name="ln596"> </a>
<a name="ln597">	if (namesz == 7 &amp;&amp; strcmp((char *)&amp;nbuf[noff], &quot;NetBSD&quot;) == 0) {</a>
<a name="ln598">	    	if (type == NT_NETBSD_VERSION &amp;&amp; descsz == 4) {</a>
<a name="ln599">			*flags |= FLAGS_DID_OS_NOTE;</a>
<a name="ln600">			do_note_netbsd_version(ms, swap, &amp;nbuf[doff]);</a>
<a name="ln601">			return 1;</a>
<a name="ln602">		}</a>
<a name="ln603">	}</a>
<a name="ln604"> </a>
<a name="ln605">	if (namesz == 8 &amp;&amp; strcmp((char *)&amp;nbuf[noff], &quot;FreeBSD&quot;) == 0) {</a>
<a name="ln606">	    	if (type == NT_FREEBSD_VERSION &amp;&amp; descsz == 4) {</a>
<a name="ln607">			*flags |= FLAGS_DID_OS_NOTE;</a>
<a name="ln608">			do_note_freebsd_version(ms, swap, &amp;nbuf[doff]);</a>
<a name="ln609">			return 1;</a>
<a name="ln610">		}</a>
<a name="ln611">	}</a>
<a name="ln612"> </a>
<a name="ln613">	if (namesz == 8 &amp;&amp; strcmp((char *)&amp;nbuf[noff], &quot;OpenBSD&quot;) == 0 &amp;&amp;</a>
<a name="ln614">	    type == NT_OPENBSD_VERSION &amp;&amp; descsz == 4) {</a>
<a name="ln615">		*flags |= FLAGS_DID_OS_NOTE;</a>
<a name="ln616">		if (file_printf(ms, &quot;, for OpenBSD&quot;) == -1)</a>
<a name="ln617">			return 1;</a>
<a name="ln618">		/* Content of note is always 0 */</a>
<a name="ln619">		return 1;</a>
<a name="ln620">	}</a>
<a name="ln621"> </a>
<a name="ln622">	if (namesz == 10 &amp;&amp; strcmp((char *)&amp;nbuf[noff], &quot;DragonFly&quot;) == 0 &amp;&amp;</a>
<a name="ln623">	    type == NT_DRAGONFLY_VERSION &amp;&amp; descsz == 4) {</a>
<a name="ln624">		uint32_t desc;</a>
<a name="ln625">		*flags |= FLAGS_DID_OS_NOTE;</a>
<a name="ln626">		if (file_printf(ms, &quot;, for DragonFly&quot;) == -1)</a>
<a name="ln627">			return 1;</a>
<a name="ln628">		(void)memcpy(&amp;desc, &amp;nbuf[doff], sizeof(desc));</a>
<a name="ln629">		desc = elf_getu32(swap, desc);</a>
<a name="ln630">		if (file_printf(ms, &quot; %d.%d.%d&quot;, desc / 100000,</a>
<a name="ln631">		    desc / 10000 % 10, desc % 10000) == -1)</a>
<a name="ln632">			return 1;</a>
<a name="ln633">		return 1;</a>
<a name="ln634">	}</a>
<a name="ln635">	return 0;</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638">private int</a>
<a name="ln639">do_pax_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,</a>
<a name="ln640">    int swap, uint32_t namesz, uint32_t descsz,</a>
<a name="ln641">    size_t noff, size_t doff, int *flags)</a>
<a name="ln642">{</a>
<a name="ln643">	if (namesz == 4 &amp;&amp; strcmp((char *)&amp;nbuf[noff], &quot;PaX&quot;) == 0 &amp;&amp;</a>
<a name="ln644">	    type == NT_NETBSD_PAX &amp;&amp; descsz == 4) {</a>
<a name="ln645">		static const char *pax[] = {</a>
<a name="ln646">		    &quot;+mprotect&quot;,</a>
<a name="ln647">		    &quot;-mprotect&quot;,</a>
<a name="ln648">		    &quot;+segvguard&quot;,</a>
<a name="ln649">		    &quot;-segvguard&quot;,</a>
<a name="ln650">		    &quot;+ASLR&quot;,</a>
<a name="ln651">		    &quot;-ASLR&quot;,</a>
<a name="ln652">		};</a>
<a name="ln653">		uint32_t desc;</a>
<a name="ln654">		size_t i;</a>
<a name="ln655">		int did = 0;</a>
<a name="ln656"> </a>
<a name="ln657">		*flags |= FLAGS_DID_NETBSD_PAX;</a>
<a name="ln658">		(void)memcpy(&amp;desc, &amp;nbuf[doff], sizeof(desc));</a>
<a name="ln659">		desc = elf_getu32(swap, desc);</a>
<a name="ln660"> </a>
<a name="ln661">		if (desc &amp;&amp; file_printf(ms, &quot;, PaX: &quot;) == -1)</a>
<a name="ln662">			return 1;</a>
<a name="ln663"> </a>
<a name="ln664">		for (i = 0; i &lt; __arraycount(pax); i++) {</a>
<a name="ln665">			if (((1 &lt;&lt; (int)i) &amp; desc) == 0)</a>
<a name="ln666">				continue;</a>
<a name="ln667">			if (file_printf(ms, &quot;%s%s&quot;, did++ ? &quot;,&quot; : &quot;&quot;,</a>
<a name="ln668">			    pax[i]) == -1)</a>
<a name="ln669">				return 1;</a>
<a name="ln670">		}</a>
<a name="ln671">		return 1;</a>
<a name="ln672">	}</a>
<a name="ln673">	return 0;</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676">private int</a>
<a name="ln677">do_core_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,</a>
<a name="ln678">    int swap, uint32_t namesz, uint32_t descsz,</a>
<a name="ln679">    size_t noff, size_t doff, int *flags, size_t size, int clazz)</a>
<a name="ln680">{</a>
<a name="ln681">#ifdef ELFCORE</a>
<a name="ln682">	int os_style = -1;</a>
<a name="ln683">	/*</a>
<a name="ln684">	 * Sigh.  The 2.0.36 kernel in Debian 2.1, at</a>
<a name="ln685">	 * least, doesn't correctly implement name</a>
<a name="ln686">	 * sections, in core dumps, as specified by</a>
<a name="ln687">	 * the &quot;Program Linking&quot; section of &quot;UNIX(R) System</a>
<a name="ln688">	 * V Release 4 Programmer's Guide: ANSI C and</a>
<a name="ln689">	 * Programming Support Tools&quot;, because my copy</a>
<a name="ln690">	 * clearly says &quot;The first 'namesz' bytes in 'name'</a>
<a name="ln691">	 * contain a *null-terminated* [emphasis mine]</a>
<a name="ln692">	 * character representation of the entry's owner</a>
<a name="ln693">	 * or originator&quot;, but the 2.0.36 kernel code</a>
<a name="ln694">	 * doesn't include the terminating null in the</a>
<a name="ln695">	 * name....</a>
<a name="ln696">	 */</a>
<a name="ln697">	if ((namesz == 4 &amp;&amp; strncmp((char *)&amp;nbuf[noff], &quot;CORE&quot;, 4) == 0) ||</a>
<a name="ln698">	    (namesz == 5 &amp;&amp; strcmp((char *)&amp;nbuf[noff], &quot;CORE&quot;) == 0)) {</a>
<a name="ln699">		os_style = OS_STYLE_SVR4;</a>
<a name="ln700">	} </a>
<a name="ln701"> </a>
<a name="ln702">	if ((namesz == 8 &amp;&amp; strcmp((char *)&amp;nbuf[noff], &quot;FreeBSD&quot;) == 0)) {</a>
<a name="ln703">		os_style = OS_STYLE_FREEBSD;</a>
<a name="ln704">	}</a>
<a name="ln705"> </a>
<a name="ln706">	if ((namesz &gt;= 11 &amp;&amp; strncmp((char *)&amp;nbuf[noff], &quot;NetBSD-CORE&quot;, 11)</a>
<a name="ln707">	    == 0)) {</a>
<a name="ln708">		os_style = OS_STYLE_NETBSD;</a>
<a name="ln709">	}</a>
<a name="ln710"> </a>
<a name="ln711">	if (os_style != -1 &amp;&amp; (*flags &amp; FLAGS_DID_CORE_STYLE) == 0) {</a>
<a name="ln712">		if (file_printf(ms, &quot;, %s-style&quot;, os_style_names[os_style])</a>
<a name="ln713">		    == -1)</a>
<a name="ln714">			return 1;</a>
<a name="ln715">		*flags |= FLAGS_DID_CORE_STYLE;</a>
<a name="ln716">		*flags |= os_style;</a>
<a name="ln717">	}</a>
<a name="ln718"> </a>
<a name="ln719">	switch (os_style) {</a>
<a name="ln720">	case OS_STYLE_NETBSD:</a>
<a name="ln721">		if (type == NT_NETBSD_CORE_PROCINFO) {</a>
<a name="ln722">			char sbuf[512];</a>
<a name="ln723">			struct NetBSD_elfcore_procinfo pi;</a>
<a name="ln724">			memset(&amp;pi, 0, sizeof(pi));</a>
<a name="ln725">			memcpy(&amp;pi, nbuf + doff, descsz);</a>
<a name="ln726"> </a>
<a name="ln727">			if (file_printf(ms, &quot;, from '%.31s', pid=%u, uid=%u, &quot;</a>
<a name="ln728">			    &quot;gid=%u, nlwps=%u, lwp=%u (signal %u/code %u)&quot;,</a>
<a name="ln729">			    file_printable(sbuf, sizeof(sbuf),</a>
<a name="ln730">			    CAST(char *, pi.cpi_name)),</a>
<a name="ln731">			    elf_getu32(swap, pi.cpi_pid),</a>
<a name="ln732">			    elf_getu32(swap, pi.cpi_euid),</a>
<a name="ln733">			    elf_getu32(swap, pi.cpi_egid),</a>
<a name="ln734">			    elf_getu32(swap, pi.cpi_nlwps),</a>
<a name="ln735">			    elf_getu32(swap, pi.cpi_siglwp),</a>
<a name="ln736">			    elf_getu32(swap, pi.cpi_signo),</a>
<a name="ln737">			    elf_getu32(swap, pi.cpi_sigcode)) == -1)</a>
<a name="ln738">				return 1;</a>
<a name="ln739"> </a>
<a name="ln740">			*flags |= FLAGS_DID_CORE;</a>
<a name="ln741">			return 1;</a>
<a name="ln742">		}</a>
<a name="ln743">		break;</a>
<a name="ln744"> </a>
<a name="ln745">	default:</a>
<a name="ln746">		if (type == NT_PRPSINFO &amp;&amp; *flags &amp; FLAGS_IS_CORE) {</a>
<a name="ln747">			size_t i, j;</a>
<a name="ln748">			unsigned char c;</a>
<a name="ln749">			/*</a>
<a name="ln750">			 * Extract the program name.  We assume</a>
<a name="ln751">			 * it to be 16 characters (that's what it</a>
<a name="ln752">			 * is in SunOS 5.x and Linux).</a>
<a name="ln753">			 *</a>
<a name="ln754">			 * Unfortunately, it's at a different offset</a>
<a name="ln755">			 * in various OSes, so try multiple offsets.</a>
<a name="ln756">			 * If the characters aren't all printable,</a>
<a name="ln757">			 * reject it.</a>
<a name="ln758">			 */</a>
<a name="ln759">			for (i = 0; i &lt; NOFFSETS; i++) {</a>
<a name="ln760">				unsigned char *cname, *cp;</a>
<a name="ln761">				size_t reloffset = prpsoffsets(i);</a>
<a name="ln762">				size_t noffset = doff + reloffset;</a>
<a name="ln763">				size_t k;</a>
<a name="ln764">				for (j = 0; j &lt; 16; j++, noffset++,</a>
<a name="ln765">				    reloffset++) {</a>
<a name="ln766">					/*</a>
<a name="ln767">					 * Make sure we're not past</a>
<a name="ln768">					 * the end of the buffer; if</a>
<a name="ln769">					 * we are, just give up.</a>
<a name="ln770">					 */</a>
<a name="ln771">					if (noffset &gt;= size)</a>
<a name="ln772">						goto tryanother;</a>
<a name="ln773"> </a>
<a name="ln774">					/*</a>
<a name="ln775">					 * Make sure we're not past</a>
<a name="ln776">					 * the end of the contents;</a>
<a name="ln777">					 * if we are, this obviously</a>
<a name="ln778">					 * isn't the right offset.</a>
<a name="ln779">					 */</a>
<a name="ln780">					if (reloffset &gt;= descsz)</a>
<a name="ln781">						goto tryanother;</a>
<a name="ln782"> </a>
<a name="ln783">					c = nbuf[noffset];</a>
<a name="ln784">					if (c == '\0') {</a>
<a name="ln785">						/*</a>
<a name="ln786">						 * A '\0' at the</a>
<a name="ln787">						 * beginning is</a>
<a name="ln788">						 * obviously wrong.</a>
<a name="ln789">						 * Any other '\0'</a>
<a name="ln790">						 * means we're done.</a>
<a name="ln791">						 */</a>
<a name="ln792">						if (j == 0)</a>
<a name="ln793">							goto tryanother;</a>
<a name="ln794">						else</a>
<a name="ln795">							break;</a>
<a name="ln796">					} else {</a>
<a name="ln797">						/*</a>
<a name="ln798">						 * A nonprintable</a>
<a name="ln799">						 * character is also</a>
<a name="ln800">						 * wrong.</a>
<a name="ln801">						 */</a>
<a name="ln802">						if (!isprint(c) || isquote(c))</a>
<a name="ln803">							goto tryanother;</a>
<a name="ln804">					}</a>
<a name="ln805">				}</a>
<a name="ln806">				/*</a>
<a name="ln807">				 * Well, that worked.</a>
<a name="ln808">				 */</a>
<a name="ln809"> </a>
<a name="ln810">				/*</a>
<a name="ln811">				 * Try next offsets, in case this match is</a>
<a name="ln812">				 * in the middle of a string.</a>
<a name="ln813">				 */</a>
<a name="ln814">				for (k = i + 1 ; k &lt; NOFFSETS; k++) {</a>
<a name="ln815">					size_t no;</a>
<a name="ln816">					int adjust = 1;</a>
<a name="ln817">					if (prpsoffsets(k) &gt;= prpsoffsets(i))</a>
<a name="ln818">						continue;</a>
<a name="ln819">					for (no = doff + prpsoffsets(k);</a>
<a name="ln820">					     no &lt; doff + prpsoffsets(i); no++)</a>
<a name="ln821">						adjust = adjust</a>
<a name="ln822">						         &amp;&amp; isprint(nbuf[no]);</a>
<a name="ln823">					if (adjust)</a>
<a name="ln824">						i = k;</a>
<a name="ln825">				}</a>
<a name="ln826"> </a>
<a name="ln827">				cname = (unsigned char *)</a>
<a name="ln828">				    &amp;nbuf[doff + prpsoffsets(i)];</a>
<a name="ln829">				for (cp = cname; *cp &amp;&amp; isprint(*cp); cp++)</a>
<a name="ln830">					continue;</a>
<a name="ln831">				/*</a>
<a name="ln832">				 * Linux apparently appends a space at the end</a>
<a name="ln833">				 * of the command line: remove it.</a>
<a name="ln834">				 */</a>
<a name="ln835">				while (cp &gt; cname &amp;&amp; isspace(cp[-1]))</a>
<a name="ln836">					cp--;</a>
<a name="ln837">				if (file_printf(ms, &quot;, from '%.*s'&quot;,</a>
<a name="ln838">				    (int)(cp - cname), cname) == -1)</a>
<a name="ln839">					return 1;</a>
<a name="ln840">				*flags |= FLAGS_DID_CORE;</a>
<a name="ln841">				return 1;</a>
<a name="ln842"> </a>
<a name="ln843">			tryanother:</a>
<a name="ln844">				;</a>
<a name="ln845">			}</a>
<a name="ln846">		}</a>
<a name="ln847">		break;</a>
<a name="ln848">	}</a>
<a name="ln849">#endif</a>
<a name="ln850">	return 0;</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853">private off_t</a>
<a name="ln854">get_offset_from_virtaddr(struct magic_set *ms, int swap, int clazz, int fd,</a>
<a name="ln855">    off_t off, int num, off_t fsize, uint64_t virtaddr)</a>
<a name="ln856">{</a>
<a name="ln857">	Elf32_Phdr ph32;</a>
<a name="ln858">	Elf64_Phdr ph64;</a>
<a name="ln859"> </a>
<a name="ln860">	/*</a>
<a name="ln861">	 * Loop through all the program headers and find the header with</a>
<a name="ln862">	 * virtual address in which the &quot;virtaddr&quot; belongs to.</a>
<a name="ln863">	 */</a>
<a name="ln864">	for ( ; num; num--) {</a>
<a name="ln865">		if (pread(fd, xph_addr, xph_sizeof, off) &lt; (ssize_t)xph_sizeof) {</a>
<a name="ln866">			file_badread(ms);</a>
<a name="ln867">			return -1;</a>
<a name="ln868">		}</a>
<a name="ln869">		off += xph_sizeof;</a>
<a name="ln870"> </a>
<a name="ln871">		if (fsize != SIZE_UNKNOWN &amp;&amp; xph_offset &gt; fsize) {</a>
<a name="ln872">			/* Perhaps warn here */</a>
<a name="ln873">			continue;</a>
<a name="ln874">		}</a>
<a name="ln875"> </a>
<a name="ln876">		if (virtaddr &gt;= xph_vaddr &amp;&amp; virtaddr &lt; xph_vaddr + xph_filesz)</a>
<a name="ln877">			return xph_offset + (virtaddr - xph_vaddr);</a>
<a name="ln878">	}</a>
<a name="ln879">	return 0;</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882">private size_t</a>
<a name="ln883">get_string_on_virtaddr(struct magic_set *ms,</a>
<a name="ln884">    int swap, int clazz, int fd, off_t ph_off, int ph_num,</a>
<a name="ln885">    off_t fsize, uint64_t virtaddr, char *buf, ssize_t buflen)</a>
<a name="ln886">{</a>
<a name="ln887">	char *bptr;</a>
<a name="ln888">	off_t offset;</a>
<a name="ln889"> </a>
<a name="ln890">	if (buflen == 0)</a>
<a name="ln891">		return 0;</a>
<a name="ln892"> </a>
<a name="ln893">	offset = get_offset_from_virtaddr(ms, swap, clazz, fd, ph_off, ph_num,</a>
<a name="ln894">	    fsize, virtaddr);</a>
<a name="ln895">	if ((buflen = pread(fd, buf, CAST(size_t, buflen), offset)) &lt;= 0) {</a>
<a name="ln896">		file_badread(ms);</a>
<a name="ln897">		return 0;</a>
<a name="ln898">	}</a>
<a name="ln899"> </a>
<a name="ln900">	buf[buflen - 1] = '\0';</a>
<a name="ln901"> </a>
<a name="ln902">	/* We expect only printable characters, so return if buffer contains</a>
<a name="ln903">	 * non-printable character before the '\0' or just '\0'. */</a>
<a name="ln904">	for (bptr = buf; *bptr &amp;&amp; isprint((unsigned char)*bptr); bptr++)</a>
<a name="ln905">		continue;</a>
<a name="ln906">	if (*bptr != '\0')</a>
<a name="ln907">		return 0;</a>
<a name="ln908"> </a>
<a name="ln909">	return bptr - buf;</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912"> </a>
<a name="ln913">private int</a>
<a name="ln914">do_auxv_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,</a>
<a name="ln915">    int swap, uint32_t namesz __attribute__((__unused__)),</a>
<a name="ln916">    uint32_t descsz __attribute__((__unused__)),</a>
<a name="ln917">    size_t noff __attribute__((__unused__)), size_t doff,</a>
<a name="ln918">    int *flags, size_t size __attribute__((__unused__)), int clazz,</a>
<a name="ln919">    int fd, off_t ph_off, int ph_num, off_t fsize)</a>
<a name="ln920">{</a>
<a name="ln921">#ifdef ELFCORE</a>
<a name="ln922">	Aux32Info auxv32;</a>
<a name="ln923">	Aux64Info auxv64;</a>
<a name="ln924">	size_t elsize = xauxv_sizeof;</a>
<a name="ln925">	const char *tag;</a>
<a name="ln926">	int is_string;</a>
<a name="ln927">	size_t nval;</a>
<a name="ln928"> </a>
<a name="ln929">	if ((*flags &amp; (FLAGS_IS_CORE|FLAGS_DID_CORE_STYLE)) !=</a>
<a name="ln930">	    (FLAGS_IS_CORE|FLAGS_DID_CORE_STYLE))</a>
<a name="ln931">		return 0;</a>
<a name="ln932"> </a>
<a name="ln933">	switch (*flags &amp; FLAGS_CORE_STYLE) {</a>
<a name="ln934">	case OS_STYLE_SVR4:</a>
<a name="ln935">		if (type != NT_AUXV)</a>
<a name="ln936">			return 0;</a>
<a name="ln937">		break;</a>
<a name="ln938">#ifdef notyet</a>
<a name="ln939">	case OS_STYLE_NETBSD:</a>
<a name="ln940">		if (type != NT_NETBSD_CORE_AUXV)</a>
<a name="ln941">			return 0;</a>
<a name="ln942">		break;</a>
<a name="ln943">	case OS_STYLE_FREEBSD:</a>
<a name="ln944">		if (type != NT_FREEBSD_PROCSTAT_AUXV)</a>
<a name="ln945">			return 0;</a>
<a name="ln946">		break;</a>
<a name="ln947">#endif</a>
<a name="ln948">	default:</a>
<a name="ln949">		return 0;</a>
<a name="ln950">	}</a>
<a name="ln951"> </a>
<a name="ln952">	*flags |= FLAGS_DID_AUXV;</a>
<a name="ln953"> </a>
<a name="ln954">	nval = 0;</a>
<a name="ln955">	for (size_t off = 0; off + elsize &lt;= descsz; off += elsize) {</a>
<a name="ln956">		(void)memcpy(xauxv_addr, &amp;nbuf[doff + off], xauxv_sizeof);</a>
<a name="ln957">		/* Limit processing to 50 vector entries to prevent DoS */</a>
<a name="ln958">		if (nval++ &gt;= 50) {</a>
<a name="ln959">			file_error(ms, 0, &quot;Too many ELF Auxv elements&quot;);</a>
<a name="ln960">			return 1;</a>
<a name="ln961">		}</a>
<a name="ln962"> </a>
<a name="ln963">		switch(xauxv_type) {</a>
<a name="ln964">		case AT_LINUX_EXECFN:</a>
<a name="ln965">			is_string = 1;</a>
<a name="ln966">			tag = &quot;execfn&quot;;</a>
<a name="ln967">			break;</a>
<a name="ln968">		case AT_LINUX_PLATFORM:</a>
<a name="ln969">			is_string = 1;</a>
<a name="ln970">			tag = &quot;platform&quot;;</a>
<a name="ln971">			break;</a>
<a name="ln972">		case AT_LINUX_UID:</a>
<a name="ln973">			is_string = 0;</a>
<a name="ln974">			tag = &quot;real uid&quot;;</a>
<a name="ln975">			break;</a>
<a name="ln976">		case AT_LINUX_GID:</a>
<a name="ln977">			is_string = 0;</a>
<a name="ln978">			tag = &quot;real gid&quot;;</a>
<a name="ln979">			break;</a>
<a name="ln980">		case AT_LINUX_EUID:</a>
<a name="ln981">			is_string = 0;</a>
<a name="ln982">			tag = &quot;effective uid&quot;;</a>
<a name="ln983">			break;</a>
<a name="ln984">		case AT_LINUX_EGID:</a>
<a name="ln985">			is_string = 0;</a>
<a name="ln986">			tag = &quot;effective gid&quot;;</a>
<a name="ln987">			break;</a>
<a name="ln988">		default:</a>
<a name="ln989">			is_string = 0;</a>
<a name="ln990">			tag = NULL;</a>
<a name="ln991">			break;</a>
<a name="ln992">		}</a>
<a name="ln993"> </a>
<a name="ln994">		if (tag == NULL)</a>
<a name="ln995">			continue;</a>
<a name="ln996"> </a>
<a name="ln997">		if (is_string) {</a>
<a name="ln998">			char buf[256];</a>
<a name="ln999">			ssize_t buflen;</a>
<a name="ln1000">			buflen = get_string_on_virtaddr(ms, swap, clazz, fd,</a>
<a name="ln1001">			    ph_off, ph_num, fsize, xauxv_val, buf, sizeof(buf));</a>
<a name="ln1002"> </a>
<a name="ln1003">			if (buflen == 0)</a>
<a name="ln1004">				continue;</a>
<a name="ln1005">			</a>
<a name="ln1006">			if (file_printf(ms, &quot;, %s: '%s'&quot;, tag, buf) == -1)</a>
<a name="ln1007">				return 0;</a>
<a name="ln1008">		} else {</a>
<a name="ln1009">			if (file_printf(ms, &quot;, %s: %d&quot;, tag, (int) xauxv_val)</a>
<a name="ln1010">			    == -1)</a>
<a name="ln1011">				return 0;</a>
<a name="ln1012">		}</a>
<a name="ln1013">	}</a>
<a name="ln1014">	return 1;</a>
<a name="ln1015">#else</a>
<a name="ln1016">	return 0;</a>
<a name="ln1017">#endif</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020">private size_t</a>
<a name="ln1021">donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,</a>
<a name="ln1022">    int clazz, int swap, size_t align, int *flags, uint16_t *notecount,</a>
<a name="ln1023">    int fd, off_t ph_off, int ph_num, off_t fsize)</a>
<a name="ln1024">{</a>
<a name="ln1025">	Elf32_Nhdr nh32;</a>
<a name="ln1026">	Elf64_Nhdr nh64;</a>
<a name="ln1027">	size_t noff, doff;</a>
<a name="ln1028">	uint32_t namesz, descsz;</a>
<a name="ln1029">	unsigned char *nbuf = CAST(unsigned char *, vbuf);</a>
<a name="ln1030"> </a>
<a name="ln1031">	if (*notecount == 0)</a>
<a name="ln1032">		return 0;</a>
<a name="ln1033">	--*notecount;</a>
<a name="ln1034"> </a>
<a name="ln1035">	if (xnh_sizeof + offset &gt; size) {</a>
<a name="ln1036">		/*</a>
<a name="ln1037">		 * We're out of note headers.</a>
<a name="ln1038">		 */</a>
<a name="ln1039">		return xnh_sizeof + offset;</a>
<a name="ln1040">	}</a>
<a name="ln1041"> </a>
<a name="ln1042">	(void)memcpy(xnh_addr, &amp;nbuf[offset], xnh_sizeof);</a>
<a name="ln1043">	offset += xnh_sizeof;</a>
<a name="ln1044"> </a>
<a name="ln1045">	namesz = xnh_namesz;</a>
<a name="ln1046">	descsz = xnh_descsz;</a>
<a name="ln1047"> </a>
<a name="ln1048">	if ((namesz == 0) &amp;&amp; (descsz == 0)) {</a>
<a name="ln1049">		/*</a>
<a name="ln1050">		 * We're out of note headers.</a>
<a name="ln1051">		 */</a>
<a name="ln1052">		return (offset &gt;= size) ? offset : size;</a>
<a name="ln1053">	}</a>
<a name="ln1054"> </a>
<a name="ln1055">	if (namesz &amp; 0x80000000) {</a>
<a name="ln1056">	    (void)file_printf(ms, &quot;, bad note name size %#lx&quot;,</a>
<a name="ln1057">		(unsigned long)namesz);</a>
<a name="ln1058">	    return 0;</a>
<a name="ln1059">	}</a>
<a name="ln1060"> </a>
<a name="ln1061">	if (descsz &amp; 0x80000000) {</a>
<a name="ln1062">	    (void)file_printf(ms, &quot;, bad note description size %#lx&quot;,</a>
<a name="ln1063">		(unsigned long)descsz);</a>
<a name="ln1064">	    return 0;</a>
<a name="ln1065">	}</a>
<a name="ln1066"> </a>
<a name="ln1067">	noff = offset;</a>
<a name="ln1068">	doff = ELF_ALIGN(offset + namesz);</a>
<a name="ln1069"> </a>
<a name="ln1070">	if (offset + namesz &gt; size) {</a>
<a name="ln1071">		/*</a>
<a name="ln1072">		 * We're past the end of the buffer.</a>
<a name="ln1073">		 */</a>
<a name="ln1074">		return doff;</a>
<a name="ln1075">	}</a>
<a name="ln1076"> </a>
<a name="ln1077">	offset = ELF_ALIGN(doff + descsz);</a>
<a name="ln1078">	if (doff + descsz &gt; size) {</a>
<a name="ln1079">		/*</a>
<a name="ln1080">		 * We're past the end of the buffer.</a>
<a name="ln1081">		 */</a>
<a name="ln1082">		return (offset &gt;= size) ? offset : size;</a>
<a name="ln1083">	}</a>
<a name="ln1084"> </a>
<a name="ln1085"> </a>
<a name="ln1086">	if ((*flags &amp; FLAGS_DID_OS_NOTE) == 0) {</a>
<a name="ln1087">		if (do_os_note(ms, nbuf, xnh_type, swap,</a>
<a name="ln1088">		    namesz, descsz, noff, doff, flags))</a>
<a name="ln1089">			return offset;</a>
<a name="ln1090">	}</a>
<a name="ln1091"> </a>
<a name="ln1092">	if ((*flags &amp; FLAGS_DID_BUILD_ID) == 0) {</a>
<a name="ln1093">		if (do_bid_note(ms, nbuf, xnh_type, swap,</a>
<a name="ln1094">		    namesz, descsz, noff, doff, flags))</a>
<a name="ln1095">			return offset;</a>
<a name="ln1096">	}</a>
<a name="ln1097">		</a>
<a name="ln1098">	if ((*flags &amp; FLAGS_DID_NETBSD_PAX) == 0) {</a>
<a name="ln1099">		if (do_pax_note(ms, nbuf, xnh_type, swap,</a>
<a name="ln1100">		    namesz, descsz, noff, doff, flags))</a>
<a name="ln1101">			return offset;</a>
<a name="ln1102">	}</a>
<a name="ln1103"> </a>
<a name="ln1104">	if ((*flags &amp; FLAGS_DID_CORE) == 0) {</a>
<a name="ln1105">		if (do_core_note(ms, nbuf, xnh_type, swap,</a>
<a name="ln1106">		    namesz, descsz, noff, doff, flags, size, clazz))</a>
<a name="ln1107">			return offset;</a>
<a name="ln1108">	}</a>
<a name="ln1109"> </a>
<a name="ln1110">	if ((*flags &amp; FLAGS_DID_AUXV) == 0) {</a>
<a name="ln1111">		if (do_auxv_note(ms, nbuf, xnh_type, swap,</a>
<a name="ln1112">			namesz, descsz, noff, doff, flags, size, clazz,</a>
<a name="ln1113">			fd, ph_off, ph_num, fsize))</a>
<a name="ln1114">			return offset;</a>
<a name="ln1115">	}</a>
<a name="ln1116"> </a>
<a name="ln1117">	if (namesz == 7 &amp;&amp; strcmp((char *)&amp;nbuf[noff], &quot;NetBSD&quot;) == 0) {</a>
<a name="ln1118">		if (descsz &gt; 100)</a>
<a name="ln1119">			descsz = 100;</a>
<a name="ln1120">		switch (xnh_type) {</a>
<a name="ln1121">	    	case NT_NETBSD_VERSION:</a>
<a name="ln1122">			return offset;</a>
<a name="ln1123">		case NT_NETBSD_MARCH:</a>
<a name="ln1124">			if (*flags &amp; FLAGS_DID_NETBSD_MARCH)</a>
<a name="ln1125">				return offset;</a>
<a name="ln1126">			*flags |= FLAGS_DID_NETBSD_MARCH;</a>
<a name="ln1127">			if (file_printf(ms, &quot;, compiled for: %.*s&quot;,</a>
<a name="ln1128">			    (int)descsz, (const char *)&amp;nbuf[doff]) == -1)</a>
<a name="ln1129">				return offset;</a>
<a name="ln1130">			break;</a>
<a name="ln1131">		case NT_NETBSD_CMODEL:</a>
<a name="ln1132">			if (*flags &amp; FLAGS_DID_NETBSD_CMODEL)</a>
<a name="ln1133">				return offset;</a>
<a name="ln1134">			*flags |= FLAGS_DID_NETBSD_CMODEL;</a>
<a name="ln1135">			if (file_printf(ms, &quot;, compiler model: %.*s&quot;,</a>
<a name="ln1136">			    (int)descsz, (const char *)&amp;nbuf[doff]) == -1)</a>
<a name="ln1137">				return offset;</a>
<a name="ln1138">			break;</a>
<a name="ln1139">		default:</a>
<a name="ln1140">			if (*flags &amp; FLAGS_DID_NETBSD_UNKNOWN)</a>
<a name="ln1141">				return offset;</a>
<a name="ln1142">			*flags |= FLAGS_DID_NETBSD_UNKNOWN;</a>
<a name="ln1143">			if (file_printf(ms, &quot;, note=%u&quot;, xnh_type) == -1)</a>
<a name="ln1144">				return offset;</a>
<a name="ln1145">			break;</a>
<a name="ln1146">		}</a>
<a name="ln1147">		return offset;</a>
<a name="ln1148">	}</a>
<a name="ln1149"> </a>
<a name="ln1150">	return offset;</a>
<a name="ln1151">}</a>
<a name="ln1152"> </a>
<a name="ln1153">/* SunOS 5.x hardware capability descriptions */</a>
<a name="ln1154">typedef struct cap_desc {</a>
<a name="ln1155">	uint64_t cd_mask;</a>
<a name="ln1156">	const char *cd_name;</a>
<a name="ln1157">} cap_desc_t;</a>
<a name="ln1158"> </a>
<a name="ln1159">static const cap_desc_t cap_desc_sparc[] = {</a>
<a name="ln1160">	{ AV_SPARC_MUL32,		&quot;MUL32&quot; },</a>
<a name="ln1161">	{ AV_SPARC_DIV32,		&quot;DIV32&quot; },</a>
<a name="ln1162">	{ AV_SPARC_FSMULD,		&quot;FSMULD&quot; },</a>
<a name="ln1163">	{ AV_SPARC_V8PLUS,		&quot;V8PLUS&quot; },</a>
<a name="ln1164">	{ AV_SPARC_POPC,		&quot;POPC&quot; },</a>
<a name="ln1165">	{ AV_SPARC_VIS,			&quot;VIS&quot; },</a>
<a name="ln1166">	{ AV_SPARC_VIS2,		&quot;VIS2&quot; },</a>
<a name="ln1167">	{ AV_SPARC_ASI_BLK_INIT,	&quot;ASI_BLK_INIT&quot; },</a>
<a name="ln1168">	{ AV_SPARC_FMAF,		&quot;FMAF&quot; },</a>
<a name="ln1169">	{ AV_SPARC_FJFMAU,		&quot;FJFMAU&quot; },</a>
<a name="ln1170">	{ AV_SPARC_IMA,			&quot;IMA&quot; },</a>
<a name="ln1171">	{ 0, NULL }</a>
<a name="ln1172">};</a>
<a name="ln1173"> </a>
<a name="ln1174">static const cap_desc_t cap_desc_386[] = {</a>
<a name="ln1175">	{ AV_386_FPU,			&quot;FPU&quot; },</a>
<a name="ln1176">	{ AV_386_TSC,			&quot;TSC&quot; },</a>
<a name="ln1177">	{ AV_386_CX8,			&quot;CX8&quot; },</a>
<a name="ln1178">	{ AV_386_SEP,			&quot;SEP&quot; },</a>
<a name="ln1179">	{ AV_386_AMD_SYSC,		&quot;AMD_SYSC&quot; },</a>
<a name="ln1180">	{ AV_386_CMOV,			&quot;CMOV&quot; },</a>
<a name="ln1181">	{ AV_386_MMX,			&quot;MMX&quot; },</a>
<a name="ln1182">	{ AV_386_AMD_MMX,		&quot;AMD_MMX&quot; },</a>
<a name="ln1183">	{ AV_386_AMD_3DNow,		&quot;AMD_3DNow&quot; },</a>
<a name="ln1184">	{ AV_386_AMD_3DNowx,		&quot;AMD_3DNowx&quot; },</a>
<a name="ln1185">	{ AV_386_FXSR,			&quot;FXSR&quot; },</a>
<a name="ln1186">	{ AV_386_SSE,			&quot;SSE&quot; },</a>
<a name="ln1187">	{ AV_386_SSE2,			&quot;SSE2&quot; },</a>
<a name="ln1188">	{ AV_386_PAUSE,			&quot;PAUSE&quot; },</a>
<a name="ln1189">	{ AV_386_SSE3,			&quot;SSE3&quot; },</a>
<a name="ln1190">	{ AV_386_MON,			&quot;MON&quot; },</a>
<a name="ln1191">	{ AV_386_CX16,			&quot;CX16&quot; },</a>
<a name="ln1192">	{ AV_386_AHF,			&quot;AHF&quot; },</a>
<a name="ln1193">	{ AV_386_TSCP,			&quot;TSCP&quot; },</a>
<a name="ln1194">	{ AV_386_AMD_SSE4A,		&quot;AMD_SSE4A&quot; },</a>
<a name="ln1195">	{ AV_386_POPCNT,		&quot;POPCNT&quot; },</a>
<a name="ln1196">	{ AV_386_AMD_LZCNT,		&quot;AMD_LZCNT&quot; },</a>
<a name="ln1197">	{ AV_386_SSSE3,			&quot;SSSE3&quot; },</a>
<a name="ln1198">	{ AV_386_SSE4_1,		&quot;SSE4.1&quot; },</a>
<a name="ln1199">	{ AV_386_SSE4_2,		&quot;SSE4.2&quot; },</a>
<a name="ln1200">	{ 0, NULL }</a>
<a name="ln1201">};</a>
<a name="ln1202"> </a>
<a name="ln1203">private int</a>
<a name="ln1204">doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,</a>
<a name="ln1205">    size_t size, off_t fsize, int mach, int strtab, int *flags,</a>
<a name="ln1206">    uint16_t *notecount)</a>
<a name="ln1207">{</a>
<a name="ln1208">	Elf32_Shdr sh32;</a>
<a name="ln1209">	Elf64_Shdr sh64;</a>
<a name="ln1210">	int stripped = 1, has_debug_info = 0;</a>
<a name="ln1211">	size_t nbadcap = 0;</a>
<a name="ln1212">	void *nbuf;</a>
<a name="ln1213">	off_t noff, coff, name_off;</a>
<a name="ln1214">	uint64_t cap_hw1 = 0;	/* SunOS 5.x hardware capabilites */</a>
<a name="ln1215">	uint64_t cap_sf1 = 0;	/* SunOS 5.x software capabilites */</a>
<a name="ln1216">	char name[50];</a>
<a name="ln1217">	ssize_t namesize;</a>
<a name="ln1218"> </a>
<a name="ln1219">	if (size != xsh_sizeof) {</a>
<a name="ln1220">		if (file_printf(ms, &quot;, corrupted section header size&quot;) == -1)</a>
<a name="ln1221">			return -1;</a>
<a name="ln1222">		return 0;</a>
<a name="ln1223">	}</a>
<a name="ln1224"> </a>
<a name="ln1225">	/* Read offset of name section to be able to read section names later */</a>
<a name="ln1226">	if (pread(fd, xsh_addr, xsh_sizeof, CAST(off_t, (off + size * strtab)))</a>
<a name="ln1227">	    &lt; (ssize_t)xsh_sizeof) {</a>
<a name="ln1228">		if (file_printf(ms, &quot;, missing section headers&quot;) == -1)</a>
<a name="ln1229">			return -1;</a>
<a name="ln1230">		return 0;</a>
<a name="ln1231">	}</a>
<a name="ln1232">	name_off = xsh_offset;</a>
<a name="ln1233"> </a>
<a name="ln1234">	for ( ; num; num--) {</a>
<a name="ln1235">		/* Read the name of this section. */</a>
<a name="ln1236">		if ((namesize = pread(fd, name, sizeof(name) - 1, name_off + xsh_name)) == -1) {</a>
<a name="ln1237">			file_badread(ms);</a>
<a name="ln1238">			return -1;</a>
<a name="ln1239">		}</a>
<a name="ln1240">		name[namesize] = '\0';</a>
<a name="ln1241">		if (strcmp(name, &quot;.debug_info&quot;) == 0) {</a>
<a name="ln1242">			has_debug_info = 1;</a>
<a name="ln1243">			stripped = 0;</a>
<a name="ln1244">		}</a>
<a name="ln1245"> </a>
<a name="ln1246">		if (pread(fd, xsh_addr, xsh_sizeof, off) &lt; (ssize_t)xsh_sizeof) {</a>
<a name="ln1247">			file_badread(ms);</a>
<a name="ln1248">			return -1;</a>
<a name="ln1249">		}</a>
<a name="ln1250">		off += size;</a>
<a name="ln1251"> </a>
<a name="ln1252">		/* Things we can determine before we seek */</a>
<a name="ln1253">		switch (xsh_type) {</a>
<a name="ln1254">		case SHT_SYMTAB:</a>
<a name="ln1255">#if 0</a>
<a name="ln1256">		case SHT_DYNSYM:</a>
<a name="ln1257">#endif</a>
<a name="ln1258">			stripped = 0;</a>
<a name="ln1259">			break;</a>
<a name="ln1260">		default:</a>
<a name="ln1261">			if (fsize != SIZE_UNKNOWN &amp;&amp; xsh_offset &gt; fsize) {</a>
<a name="ln1262">				/* Perhaps warn here */</a>
<a name="ln1263">				continue;</a>
<a name="ln1264">			}</a>
<a name="ln1265">			break;</a>
<a name="ln1266">		}</a>
<a name="ln1267"> </a>
<a name="ln1268"> </a>
<a name="ln1269">		/* Things we can determine when we seek */</a>
<a name="ln1270">		switch (xsh_type) {</a>
<a name="ln1271">		case SHT_NOTE:</a>
<a name="ln1272">			if ((uintmax_t)(xsh_size + xsh_offset) &gt;</a>
<a name="ln1273">			    (uintmax_t)fsize) {</a>
<a name="ln1274">				if (file_printf(ms,</a>
<a name="ln1275">				    &quot;, note offset/size %#&quot; INTMAX_T_FORMAT</a>
<a name="ln1276">				    &quot;x+%#&quot; INTMAX_T_FORMAT &quot;x exceeds&quot;</a>
<a name="ln1277">				    &quot; file size %#&quot; INTMAX_T_FORMAT &quot;x&quot;,</a>
<a name="ln1278">				    (uintmax_t)xsh_offset, (uintmax_t)xsh_size,</a>
<a name="ln1279">				    (uintmax_t)fsize) == -1)</a>
<a name="ln1280">					return -1;</a>
<a name="ln1281">				return 0; </a>
<a name="ln1282">			}</a>
<a name="ln1283">			if ((nbuf = malloc(xsh_size)) == NULL) {</a>
<a name="ln1284">				file_error(ms, errno, &quot;Cannot allocate memory&quot;</a>
<a name="ln1285">				    &quot; for note&quot;);</a>
<a name="ln1286">				return -1;</a>
<a name="ln1287">			}</a>
<a name="ln1288">			if (pread(fd, nbuf, xsh_size, xsh_offset) &lt;</a>
<a name="ln1289">			    (ssize_t)xsh_size) {</a>
<a name="ln1290">				file_badread(ms);</a>
<a name="ln1291">				free(nbuf);</a>
<a name="ln1292">				return -1;</a>
<a name="ln1293">			}</a>
<a name="ln1294"> </a>
<a name="ln1295">			noff = 0;</a>
<a name="ln1296">			for (;;) {</a>
<a name="ln1297">				if (noff &gt;= (off_t)xsh_size)</a>
<a name="ln1298">					break;</a>
<a name="ln1299">				noff = donote(ms, nbuf, (size_t)noff,</a>
<a name="ln1300">				    xsh_size, clazz, swap, 4, flags, notecount,</a>
<a name="ln1301">				    fd, 0, 0, 0);</a>
<a name="ln1302">				if (noff == 0)</a>
<a name="ln1303">					break;</a>
<a name="ln1304">			}</a>
<a name="ln1305">			free(nbuf);</a>
<a name="ln1306">			break;</a>
<a name="ln1307">		case SHT_SUNW_cap:</a>
<a name="ln1308">			switch (mach) {</a>
<a name="ln1309">			case EM_SPARC:</a>
<a name="ln1310">			case EM_SPARCV9:</a>
<a name="ln1311">			case EM_IA_64:</a>
<a name="ln1312">			case EM_386:</a>
<a name="ln1313">			case EM_AMD64:</a>
<a name="ln1314">				break;</a>
<a name="ln1315">			default:</a>
<a name="ln1316">				goto skip;</a>
<a name="ln1317">			}</a>
<a name="ln1318"> </a>
<a name="ln1319">			if (nbadcap &gt; 5)</a>
<a name="ln1320">				break;</a>
<a name="ln1321">			if (lseek(fd, xsh_offset, SEEK_SET) == (off_t)-1) {</a>
<a name="ln1322">				file_badseek(ms);</a>
<a name="ln1323">				return -1;</a>
<a name="ln1324">			}</a>
<a name="ln1325">			coff = 0;</a>
<a name="ln1326">			for (;;) {</a>
<a name="ln1327">				Elf32_Cap cap32;</a>
<a name="ln1328">				Elf64_Cap cap64;</a>
<a name="ln1329">				char cbuf[/*CONSTCOND*/</a>
<a name="ln1330">				    MAX(sizeof cap32, sizeof cap64)];</a>
<a name="ln1331">				if ((coff += xcap_sizeof) &gt; (off_t)xsh_size)</a>
<a name="ln1332">					break;</a>
<a name="ln1333">				if (read(fd, cbuf, (size_t)xcap_sizeof) !=</a>
<a name="ln1334">				    (ssize_t)xcap_sizeof) {</a>
<a name="ln1335">					file_badread(ms);</a>
<a name="ln1336">					return -1;</a>
<a name="ln1337">				}</a>
<a name="ln1338">				if (cbuf[0] == 'A') {</a>
<a name="ln1339">#ifdef notyet</a>
<a name="ln1340">					char *p = cbuf + 1;</a>
<a name="ln1341">					uint32_t len, tag;</a>
<a name="ln1342">					memcpy(&amp;len, p, sizeof(len));</a>
<a name="ln1343">					p += 4;</a>
<a name="ln1344">					len = getu32(swap, len);</a>
<a name="ln1345">					if (memcmp(&quot;gnu&quot;, p, 3) != 0) {</a>
<a name="ln1346">					    if (file_printf(ms,</a>
<a name="ln1347">						&quot;, unknown capability %.3s&quot;, p)</a>
<a name="ln1348">						== -1)</a>
<a name="ln1349">						return -1;</a>
<a name="ln1350">					    break;</a>
<a name="ln1351">					}</a>
<a name="ln1352">					p += strlen(p) + 1;</a>
<a name="ln1353">					tag = *p++;</a>
<a name="ln1354">					memcpy(&amp;len, p, sizeof(len));</a>
<a name="ln1355">					p += 4;</a>
<a name="ln1356">					len = getu32(swap, len);</a>
<a name="ln1357">					if (tag != 1) {</a>
<a name="ln1358">					    if (file_printf(ms, &quot;, unknown gnu&quot;</a>
<a name="ln1359">						&quot; capability tag %d&quot;, tag)</a>
<a name="ln1360">						== -1)</a>
<a name="ln1361">						return -1;</a>
<a name="ln1362">					    break;</a>
<a name="ln1363">					}</a>
<a name="ln1364">					// gnu attributes </a>
<a name="ln1365">#endif</a>
<a name="ln1366">					break;</a>
<a name="ln1367">				}</a>
<a name="ln1368">				(void)memcpy(xcap_addr, cbuf, xcap_sizeof);</a>
<a name="ln1369">				switch (xcap_tag) {</a>
<a name="ln1370">				case CA_SUNW_NULL:</a>
<a name="ln1371">					break;</a>
<a name="ln1372">				case CA_SUNW_HW_1:</a>
<a name="ln1373">					cap_hw1 |= xcap_val;</a>
<a name="ln1374">					break;</a>
<a name="ln1375">				case CA_SUNW_SF_1:</a>
<a name="ln1376">					cap_sf1 |= xcap_val;</a>
<a name="ln1377">					break;</a>
<a name="ln1378">				default:</a>
<a name="ln1379">					if (file_printf(ms,</a>
<a name="ln1380">					    &quot;, with unknown capability &quot;</a>
<a name="ln1381">					    &quot;%#&quot; INT64_T_FORMAT &quot;x = %#&quot;</a>
<a name="ln1382">					    INT64_T_FORMAT &quot;x&quot;,</a>
<a name="ln1383">					    (unsigned long long)xcap_tag,</a>
<a name="ln1384">					    (unsigned long long)xcap_val) == -1)</a>
<a name="ln1385">						return -1;</a>
<a name="ln1386">					if (nbadcap++ &gt; 2)</a>
<a name="ln1387">						coff = xsh_size;</a>
<a name="ln1388">					break;</a>
<a name="ln1389">				}</a>
<a name="ln1390">			}</a>
<a name="ln1391">			/*FALLTHROUGH*/</a>
<a name="ln1392">		skip:</a>
<a name="ln1393">		default:</a>
<a name="ln1394">			break;</a>
<a name="ln1395">		}</a>
<a name="ln1396">	}</a>
<a name="ln1397"> </a>
<a name="ln1398">	if (has_debug_info) {</a>
<a name="ln1399">		if (file_printf(ms, &quot;, with debug_info&quot;) == -1)</a>
<a name="ln1400">			return -1;</a>
<a name="ln1401">	}</a>
<a name="ln1402">	if (file_printf(ms, &quot;, %sstripped&quot;, stripped ? &quot;&quot; : &quot;not &quot;) == -1)</a>
<a name="ln1403">		return -1;</a>
<a name="ln1404">	if (cap_hw1) {</a>
<a name="ln1405">		const cap_desc_t *cdp;</a>
<a name="ln1406">		switch (mach) {</a>
<a name="ln1407">		case EM_SPARC:</a>
<a name="ln1408">		case EM_SPARC32PLUS:</a>
<a name="ln1409">		case EM_SPARCV9:</a>
<a name="ln1410">			cdp = cap_desc_sparc;</a>
<a name="ln1411">			break;</a>
<a name="ln1412">		case EM_386:</a>
<a name="ln1413">		case EM_IA_64:</a>
<a name="ln1414">		case EM_AMD64:</a>
<a name="ln1415">			cdp = cap_desc_386;</a>
<a name="ln1416">			break;</a>
<a name="ln1417">		default:</a>
<a name="ln1418">			cdp = NULL;</a>
<a name="ln1419">			break;</a>
<a name="ln1420">		}</a>
<a name="ln1421">		if (file_printf(ms, &quot;, uses&quot;) == -1)</a>
<a name="ln1422">			return -1;</a>
<a name="ln1423">		if (cdp) {</a>
<a name="ln1424">			while (cdp-&gt;cd_name) {</a>
<a name="ln1425">				if (cap_hw1 &amp; cdp-&gt;cd_mask) {</a>
<a name="ln1426">					if (file_printf(ms,</a>
<a name="ln1427">					    &quot; %s&quot;, cdp-&gt;cd_name) == -1)</a>
<a name="ln1428">						return -1;</a>
<a name="ln1429">					cap_hw1 &amp;= ~cdp-&gt;cd_mask;</a>
<a name="ln1430">				}</a>
<a name="ln1431">				++cdp;</a>
<a name="ln1432">			}</a>
<a name="ln1433">			if (cap_hw1)</a>
<a name="ln1434">				if (file_printf(ms,</a>
<a name="ln1435">				    &quot; unknown hardware capability %#&quot;</a>
<a name="ln1436">				    INT64_T_FORMAT &quot;x&quot;,</a>
<a name="ln1437">				    (unsigned long long)cap_hw1) == -1)</a>
<a name="ln1438">					return -1;</a>
<a name="ln1439">		} else {</a>
<a name="ln1440">			if (file_printf(ms,</a>
<a name="ln1441">			    &quot; hardware capability %#&quot; INT64_T_FORMAT &quot;x&quot;,</a>
<a name="ln1442">			    (unsigned long long)cap_hw1) == -1)</a>
<a name="ln1443">				return -1;</a>
<a name="ln1444">		}</a>
<a name="ln1445">	}</a>
<a name="ln1446">	if (cap_sf1) {</a>
<a name="ln1447">		if (cap_sf1 &amp; SF1_SUNW_FPUSED) {</a>
<a name="ln1448">			if (file_printf(ms,</a>
<a name="ln1449">			    (cap_sf1 &amp; SF1_SUNW_FPKNWN)</a>
<a name="ln1450">			    ? &quot;, uses frame pointer&quot;</a>
<a name="ln1451">			    : &quot;, not known to use frame pointer&quot;) == -1)</a>
<a name="ln1452">				return -1;</a>
<a name="ln1453">		}</a>
<a name="ln1454">		cap_sf1 &amp;= ~SF1_SUNW_MASK;</a>
<a name="ln1455">		if (cap_sf1)</a>
<a name="ln1456">			if (file_printf(ms,</a>
<a name="ln1457">			    &quot;, with unknown software capability %#&quot;</a>
<a name="ln1458">			    INT64_T_FORMAT &quot;x&quot;,</a>
<a name="ln1459">			    (unsigned long long)cap_sf1) == -1)</a>
<a name="ln1460">				return -1;</a>
<a name="ln1461">	}</a>
<a name="ln1462">	return 0;</a>
<a name="ln1463">}</a>
<a name="ln1464"> </a>
<a name="ln1465">/*</a>
<a name="ln1466"> * Look through the program headers of an executable image, searching</a>
<a name="ln1467"> * for a PT_INTERP section; if one is found, it's dynamically linked,</a>
<a name="ln1468"> * otherwise it's statically linked.</a>
<a name="ln1469"> */</a>
<a name="ln1470">private int</a>
<a name="ln1471">dophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,</a>
<a name="ln1472">    int num, size_t size, off_t fsize, int sh_num, int *flags,</a>
<a name="ln1473">    uint16_t *notecount)</a>
<a name="ln1474">{</a>
<a name="ln1475">	Elf32_Phdr ph32;</a>
<a name="ln1476">	Elf64_Phdr ph64;</a>
<a name="ln1477">	const char *linking_style = &quot;statically&quot;;</a>
<a name="ln1478">	const char *interp = &quot;&quot;;</a>
<a name="ln1479">	unsigned char nbuf[BUFSIZ];</a>
<a name="ln1480">	char ibuf[BUFSIZ];</a>
<a name="ln1481">	ssize_t bufsize;</a>
<a name="ln1482">	size_t offset, align, len;</a>
<a name="ln1483">	</a>
<a name="ln1484">	if (size != xph_sizeof) {</a>
<a name="ln1485">		if (file_printf(ms, &quot;, corrupted program header size&quot;) == -1)</a>
<a name="ln1486">			return -1;</a>
<a name="ln1487">		return 0;</a>
<a name="ln1488">	}</a>
<a name="ln1489"> </a>
<a name="ln1490">  	for ( ; num; num--) {</a>
<a name="ln1491">		if (pread(fd, xph_addr, xph_sizeof, off) &lt; (ssize_t)xph_sizeof) {</a>
<a name="ln1492">			file_badread(ms);</a>
<a name="ln1493">			return -1;</a>
<a name="ln1494">		}</a>
<a name="ln1495"> </a>
<a name="ln1496">		off += size;</a>
<a name="ln1497">		bufsize = 0;</a>
<a name="ln1498">		align = 4;</a>
<a name="ln1499"> </a>
<a name="ln1500">		/* Things we can determine before we seek */</a>
<a name="ln1501">		switch (xph_type) {</a>
<a name="ln1502">		case PT_DYNAMIC:</a>
<a name="ln1503">			linking_style = &quot;dynamically&quot;;</a>
<a name="ln1504">			break;</a>
<a name="ln1505">		case PT_NOTE:</a>
<a name="ln1506">			if (sh_num)	/* Did this through section headers */</a>
<a name="ln1507">				continue;</a>
<a name="ln1508">			if (((align = xph_align) &amp; 0x80000000UL) != 0 ||</a>
<a name="ln1509">			    align &lt; 4) {</a>
<a name="ln1510">				if (file_printf(ms, </a>
<a name="ln1511">				    &quot;, invalid note alignment %#lx&quot;,</a>
<a name="ln1512">				    (unsigned long)align) == -1)</a>
<a name="ln1513">					return -1;</a>
<a name="ln1514">				align = 4;</a>
<a name="ln1515">			}</a>
<a name="ln1516">			/*FALLTHROUGH*/</a>
<a name="ln1517">		case PT_INTERP:</a>
<a name="ln1518">			len = xph_filesz &lt; sizeof(nbuf) ? xph_filesz</a>
<a name="ln1519">			    : sizeof(nbuf);</a>
<a name="ln1520">			bufsize = pread(fd, nbuf, len, xph_offset);</a>
<a name="ln1521">			if (bufsize == -1) {</a>
<a name="ln1522">				file_badread(ms);</a>
<a name="ln1523">				return -1;</a>
<a name="ln1524">			}</a>
<a name="ln1525">			break;</a>
<a name="ln1526">		default:</a>
<a name="ln1527">			if (fsize != SIZE_UNKNOWN &amp;&amp; xph_offset &gt; fsize) {</a>
<a name="ln1528">				/* Maybe warn here? */</a>
<a name="ln1529">				continue;</a>
<a name="ln1530">			}</a>
<a name="ln1531">			break;</a>
<a name="ln1532">		}</a>
<a name="ln1533"> </a>
<a name="ln1534">		/* Things we can determine when we seek */</a>
<a name="ln1535">		switch (xph_type) {</a>
<a name="ln1536">		case PT_INTERP:</a>
<a name="ln1537">			if (bufsize &amp;&amp; nbuf[0]) {</a>
<a name="ln1538">				nbuf[bufsize - 1] = '\0';</a>
<a name="ln1539">				interp = (const char *)nbuf;</a>
<a name="ln1540">			} else</a>
<a name="ln1541">				interp = &quot;*empty*&quot;;</a>
<a name="ln1542">			break;</a>
<a name="ln1543">		case PT_NOTE:</a>
<a name="ln1544">			/*</a>
<a name="ln1545">			 * This is a PT_NOTE section; loop through all the notes</a>
<a name="ln1546">			 * in the section.</a>
<a name="ln1547">			 */</a>
<a name="ln1548">			offset = 0;</a>
<a name="ln1549">			for (;;) {</a>
<a name="ln1550">				if (offset &gt;= (size_t)bufsize)</a>
<a name="ln1551">					break;</a>
<a name="ln1552">				offset = donote(ms, nbuf, offset,</a>
<a name="ln1553">				    (size_t)bufsize, clazz, swap, align,</a>
<a name="ln1554">				    flags, notecount, fd, 0, 0, 0);</a>
<a name="ln1555">				if (offset == 0)</a>
<a name="ln1556">					break;</a>
<a name="ln1557">			}</a>
<a name="ln1558">			break;</a>
<a name="ln1559">		default:</a>
<a name="ln1560">			break;</a>
<a name="ln1561">		}</a>
<a name="ln1562">	}</a>
<a name="ln1563">	if (file_printf(ms, &quot;, %s linked&quot;, linking_style)</a>
<a name="ln1564">	    == -1)</a>
<a name="ln1565">		return -1;</a>
<a name="ln1566">	if (interp[0])</a>
<a name="ln1567">		if (file_printf(ms, &quot;, interpreter %s&quot;,</a>
<a name="ln1568">		    file_printable(ibuf, sizeof(ibuf), interp)) == -1)</a>
<a name="ln1569">			return -1;</a>
<a name="ln1570">	return 0;</a>
<a name="ln1571">}</a>
<a name="ln1572"> </a>
<a name="ln1573"> </a>
<a name="ln1574">protected int</a>
<a name="ln1575">file_tryelf(struct magic_set *ms, int fd, const unsigned char *buf,</a>
<a name="ln1576">    size_t nbytes)</a>
<a name="ln1577">{</a>
<a name="ln1578">	union {</a>
<a name="ln1579">		int32_t l;</a>
<a name="ln1580">		char c[sizeof (int32_t)];</a>
<a name="ln1581">	} u;</a>
<a name="ln1582">	int clazz;</a>
<a name="ln1583">	int swap;</a>
<a name="ln1584">	struct stat st;</a>
<a name="ln1585">	off_t fsize;</a>
<a name="ln1586">	int flags = 0;</a>
<a name="ln1587">	Elf32_Ehdr elf32hdr;</a>
<a name="ln1588">	Elf64_Ehdr elf64hdr;</a>
<a name="ln1589">	uint16_t type, phnum, shnum, notecount;</a>
<a name="ln1590"> </a>
<a name="ln1591">	if (ms-&gt;flags &amp; (MAGIC_MIME|MAGIC_APPLE|MAGIC_EXTENSION))</a>
<a name="ln1592">		return 0;</a>
<a name="ln1593">	/*</a>
<a name="ln1594">	 * ELF executables have multiple section headers in arbitrary</a>
<a name="ln1595">	 * file locations and thus file(1) cannot determine it from easily.</a>
<a name="ln1596">	 * Instead we traverse thru all section headers until a symbol table</a>
<a name="ln1597">	 * one is found or else the binary is stripped.</a>
<a name="ln1598">	 * Return immediately if it's not ELF (so we avoid pipe2file unless needed).</a>
<a name="ln1599">	 */</a>
<a name="ln1600">	if (buf[EI_MAG0] != ELFMAG0</a>
<a name="ln1601">	    || (buf[EI_MAG1] != ELFMAG1 &amp;&amp; buf[EI_MAG1] != OLFMAG1)</a>
<a name="ln1602">	    || buf[EI_MAG2] != ELFMAG2 || buf[EI_MAG3] != ELFMAG3)</a>
<a name="ln1603">		return 0;</a>
<a name="ln1604"> </a>
<a name="ln1605">	/*</a>
<a name="ln1606">	 * If we cannot seek, it must be a pipe, socket or fifo.</a>
<a name="ln1607">	 */</a>
<a name="ln1608">	if((lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1) &amp;&amp; (errno == ESPIPE))</a>
<a name="ln1609">		fd = file_pipe2file(ms, fd, buf, nbytes);</a>
<a name="ln1610"> </a>
<a name="ln1611">	if (fstat(fd, &amp;st) == -1) {</a>
<a name="ln1612">  		file_badread(ms);</a>
<a name="ln1613">		return -1;</a>
<a name="ln1614">	}</a>
<a name="ln1615">	if (S_ISREG(st.st_mode) || st.st_size != 0)</a>
<a name="ln1616">		fsize = st.st_size;</a>
<a name="ln1617">	else</a>
<a name="ln1618">		fsize = SIZE_UNKNOWN;</a>
<a name="ln1619"> </a>
<a name="ln1620">	clazz = buf[EI_CLASS];</a>
<a name="ln1621"> </a>
<a name="ln1622">	switch (clazz) {</a>
<a name="ln1623">	case ELFCLASS32:</a>
<a name="ln1624">#undef elf_getu</a>
<a name="ln1625">#define elf_getu(a, b)	elf_getu32(a, b)</a>
<a name="ln1626">#undef elfhdr</a>
<a name="ln1627">#define elfhdr elf32hdr</a>
<a name="ln1628">#include &quot;elfclass.h&quot;</a>
<a name="ln1629">	case ELFCLASS64:</a>
<a name="ln1630">#undef elf_getu</a>
<a name="ln1631">#define elf_getu(a, b)	elf_getu64(a, b)</a>
<a name="ln1632">#undef elfhdr</a>
<a name="ln1633">#define elfhdr elf64hdr</a>
<a name="ln1634">#include &quot;elfclass.h&quot;</a>
<a name="ln1635">	default:</a>
<a name="ln1636">	    if (file_printf(ms, &quot;, unknown class %d&quot;, clazz) == -1)</a>
<a name="ln1637">		    return -1;</a>
<a name="ln1638">	    break;</a>
<a name="ln1639">	}</a>
<a name="ln1640">	return 0;</a>
<a name="ln1641">}</a>
<a name="ln1642">#endif</a>
</code></pre>
<div class="balloon" rel="516"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: descsz &lt;= 20.</p></div>
<div class="balloon" rel="500"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'file_printf' function. The SIGNED integer type argument is expected.</p></div>
<div class="balloon" rel="591"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'file_printf' function. The SIGNED integer type argument is expected.</p></div>
<div class="balloon" rel="591"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'file_printf' function. The SIGNED integer type argument is expected.</p></div>
<div class="balloon" rel="591"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'file_printf' function. The SIGNED integer type argument is expected.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>