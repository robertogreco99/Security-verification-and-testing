<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>readcdf.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com</a>
<a name="ln3">/*-</a>
<a name="ln4"> * Copyright (c) 2008, 2016 Christos Zoulas</a>
<a name="ln5"> * All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln8"> * modification, are permitted provided that the following conditions</a>
<a name="ln9"> * are met:</a>
<a name="ln10"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln11"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln12"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln13"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln14"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln15"> *</a>
<a name="ln16"> * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS</a>
<a name="ln17"> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED</a>
<a name="ln18"> * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</a>
<a name="ln19"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS</a>
<a name="ln20"> * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<a name="ln21"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln22"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln23"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<a name="ln24"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln25"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</a>
<a name="ln26"> * POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln27"> */</a>
<a name="ln28">#include &quot;file.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#ifndef lint</a>
<a name="ln31">FILE_RCSID(&quot;@(#)$File: readcdf.c,v 1.65 2017/04/08 20:58:03 christos Exp $&quot;)</a>
<a name="ln32">#endif</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;assert.h&gt;</a>
<a name="ln35">#include &lt;stdlib.h&gt;</a>
<a name="ln36">#include &lt;unistd.h&gt;</a>
<a name="ln37">#include &lt;string.h&gt;</a>
<a name="ln38">#include &lt;time.h&gt;</a>
<a name="ln39">#include &lt;ctype.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41">#include &quot;cdf.h&quot;</a>
<a name="ln42">#include &quot;magic.h&quot;</a>
<a name="ln43"> </a>
<a name="ln44">#ifndef __arraycount</a>
<a name="ln45">#define __arraycount(a) (sizeof(a) / sizeof(a[0]))</a>
<a name="ln46">#endif</a>
<a name="ln47"> </a>
<a name="ln48">#define NOTMIME(ms) (((ms)-&gt;flags &amp; MAGIC_MIME) == 0)</a>
<a name="ln49"> </a>
<a name="ln50">static const struct nv {</a>
<a name="ln51">	const char *pattern;</a>
<a name="ln52">	const char *mime;</a>
<a name="ln53">} app2mime[] =  {</a>
<a name="ln54">	{ &quot;Word&quot;,			&quot;msword&quot;,		},</a>
<a name="ln55">	{ &quot;Excel&quot;,			&quot;vnd.ms-excel&quot;,		},</a>
<a name="ln56">	{ &quot;Powerpoint&quot;,			&quot;vnd.ms-powerpoint&quot;,	},</a>
<a name="ln57">	{ &quot;Crystal Reports&quot;,		&quot;x-rpt&quot;,		},</a>
<a name="ln58">	{ &quot;Advanced Installer&quot;,		&quot;vnd.ms-msi&quot;,		},</a>
<a name="ln59">	{ &quot;InstallShield&quot;,		&quot;vnd.ms-msi&quot;,		},</a>
<a name="ln60">	{ &quot;Microsoft Patch Compiler&quot;,	&quot;vnd.ms-msi&quot;,		},</a>
<a name="ln61">	{ &quot;NAnt&quot;,			&quot;vnd.ms-msi&quot;,		},</a>
<a name="ln62">	{ &quot;Windows Installer&quot;,		&quot;vnd.ms-msi&quot;,		},</a>
<a name="ln63">	{ NULL,				NULL,			},</a>
<a name="ln64">}, name2mime[] = {</a>
<a name="ln65">	{ &quot;Book&quot;,			&quot;vnd.ms-excel&quot;,		},</a>
<a name="ln66">	{ &quot;Workbook&quot;,			&quot;vnd.ms-excel&quot;,		},</a>
<a name="ln67">	{ &quot;WordDocument&quot;,		&quot;msword&quot;,		},</a>
<a name="ln68">	{ &quot;PowerPoint&quot;,			&quot;vnd.ms-powerpoint&quot;,	},</a>
<a name="ln69">	{ &quot;DigitalSignature&quot;,		&quot;vnd.ms-msi&quot;,		},</a>
<a name="ln70">	{ NULL,				NULL,			},</a>
<a name="ln71">}, name2desc[] = {</a>
<a name="ln72">	{ &quot;Book&quot;,			&quot;Microsoft Excel&quot;,	},</a>
<a name="ln73">	{ &quot;Workbook&quot;,			&quot;Microsoft Excel&quot;,	},</a>
<a name="ln74">	{ &quot;WordDocument&quot;,		&quot;Microsoft Word&quot;,	},</a>
<a name="ln75">	{ &quot;PowerPoint&quot;,			&quot;Microsoft PowerPoint&quot;,	},</a>
<a name="ln76">	{ &quot;DigitalSignature&quot;,		&quot;Microsoft Installer&quot;,	},</a>
<a name="ln77">	{ NULL,				NULL,			},</a>
<a name="ln78">};</a>
<a name="ln79"> </a>
<a name="ln80">static const struct cv {</a>
<a name="ln81">	uint64_t clsid[2];</a>
<a name="ln82">	const char *mime;</a>
<a name="ln83">} clsid2mime[] = {</a>
<a name="ln84">	{</a>
<a name="ln85">		{ 0x00000000000c1084ULL, 0x46000000000000c0ULL  },</a>
<a name="ln86">		&quot;x-msi&quot;,</a>
<a name="ln87">	},</a>
<a name="ln88">	{	{ 0,			 0			},</a>
<a name="ln89">		NULL,</a>
<a name="ln90">	},</a>
<a name="ln91">}, clsid2desc[] = {</a>
<a name="ln92">	{</a>
<a name="ln93">		{ 0x00000000000c1084ULL, 0x46000000000000c0ULL  },</a>
<a name="ln94">		&quot;MSI Installer&quot;,</a>
<a name="ln95">	},</a>
<a name="ln96">	{	{ 0,			 0			},</a>
<a name="ln97">		NULL,</a>
<a name="ln98">	},</a>
<a name="ln99">};</a>
<a name="ln100"> </a>
<a name="ln101">private const char *</a>
<a name="ln102">cdf_clsid_to_mime(const uint64_t clsid[2], const struct cv *cv)</a>
<a name="ln103">{</a>
<a name="ln104">	size_t i;</a>
<a name="ln105">	for (i = 0; cv[i].mime != NULL; i++) {</a>
<a name="ln106">		if (clsid[0] == cv[i].clsid[0] &amp;&amp; clsid[1] == cv[i].clsid[1])</a>
<a name="ln107">			return cv[i].mime;</a>
<a name="ln108">	}</a>
<a name="ln109">#ifdef CDF_DEBUG</a>
<a name="ln110">	fprintf(stderr, &quot;unknown mime %&quot; PRIx64 &quot;, %&quot; PRIx64 &quot;\n&quot;, clsid[0],</a>
<a name="ln111">	    clsid[1]);</a>
<a name="ln112">#endif</a>
<a name="ln113">	return NULL;</a>
<a name="ln114">}</a>
<a name="ln115"> </a>
<a name="ln116">private const char *</a>
<a name="ln117">cdf_app_to_mime(const char *vbuf, const struct nv *nv)</a>
<a name="ln118">{</a>
<a name="ln119">	size_t i;</a>
<a name="ln120">	const char *rv = NULL;</a>
<a name="ln121">#ifdef USE_C_LOCALE</a>
<a name="ln122">	locale_t old_lc_ctype, c_lc_ctype;</a>
<a name="ln123"> </a>
<a name="ln124">	c_lc_ctype = newlocale(LC_CTYPE_MASK, &quot;C&quot;, 0);</a>
<a name="ln125">	assert(c_lc_ctype != NULL);</a>
<a name="ln126">	old_lc_ctype = uselocale(c_lc_ctype);</a>
<a name="ln127">	assert(old_lc_ctype != NULL);</a>
<a name="ln128">#else</a>
<a name="ln129">	char *old_lc_ctype = setlocale(LC_CTYPE, &quot;C&quot;);</a>
<a name="ln130">#endif</a>
<a name="ln131">	for (i = 0; nv[i].pattern != NULL; i++)</a>
<a name="ln132">		if (strcasestr(vbuf, nv[i].pattern) != NULL) {</a>
<a name="ln133">			rv = nv[i].mime;</a>
<a name="ln134">			break;</a>
<a name="ln135">		}</a>
<a name="ln136">#ifdef CDF_DEBUG</a>
<a name="ln137">	fprintf(stderr, &quot;unknown app %s\n&quot;, vbuf);</a>
<a name="ln138">#endif</a>
<a name="ln139">#ifdef USE_C_LOCALE</a>
<a name="ln140">	(void)uselocale(old_lc_ctype);</a>
<a name="ln141">	freelocale(c_lc_ctype);</a>
<a name="ln142">#else</a>
<a name="ln143">	setlocale(LC_CTYPE, old_lc_ctype);</a>
<a name="ln144">#endif</a>
<a name="ln145">	return rv;</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">private int</a>
<a name="ln149">cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,</a>
<a name="ln150">    size_t count, const cdf_directory_t *root_storage)</a>
<a name="ln151">{</a>
<a name="ln152">        size_t i;</a>
<a name="ln153">        cdf_timestamp_t tp;</a>
<a name="ln154">        struct timespec ts;</a>
<a name="ln155">        char buf[64];</a>
<a name="ln156">        const char *str = NULL;</a>
<a name="ln157">        const char *s, *e;</a>
<a name="ln158">        int len;</a>
<a name="ln159"> </a>
<a name="ln160">        if (!NOTMIME(ms) &amp;&amp; root_storage)</a>
<a name="ln161">		str = cdf_clsid_to_mime(root_storage-&gt;d_storage_uuid,</a>
<a name="ln162">		    clsid2mime);</a>
<a name="ln163"> </a>
<a name="ln164">        for (i = 0; i &lt; count; i++) {</a>
<a name="ln165">                cdf_print_property_name(buf, sizeof(buf), info[i].pi_id);</a>
<a name="ln166">                switch (info[i].pi_type) {</a>
<a name="ln167">                case CDF_NULL:</a>
<a name="ln168">                        break;</a>
<a name="ln169">                case CDF_SIGNED16:</a>
<a name="ln170">                        if (NOTMIME(ms) &amp;&amp; file_printf(ms, &quot;, %s: %hd&quot;, buf,</a>
<a name="ln171">                            info[i].pi_s16) == -1)</a>
<a name="ln172">                                return -1;</a>
<a name="ln173">                        break;</a>
<a name="ln174">                case CDF_SIGNED32:</a>
<a name="ln175">                        if (NOTMIME(ms) &amp;&amp; file_printf(ms, &quot;, %s: %d&quot;, buf,</a>
<a name="ln176">                            info[i].pi_s32) == -1)</a>
<a name="ln177">                                return -1;</a>
<a name="ln178">                        break;</a>
<a name="ln179">                case CDF_UNSIGNED32:</a>
<a name="ln180">                        if (NOTMIME(ms) &amp;&amp; file_printf(ms, &quot;, %s: %u&quot;, buf,</a>
<a name="ln181">                            info[i].pi_u32) == -1)</a>
<a name="ln182">                                return -1;</a>
<a name="ln183">                        break;</a>
<a name="ln184">                case CDF_FLOAT:</a>
<a name="ln185">                        if (NOTMIME(ms) &amp;&amp; file_printf(ms, &quot;, %s: %g&quot;, buf,</a>
<a name="ln186">                            info[i].pi_f) == -1)</a>
<a name="ln187">                                return -1;</a>
<a name="ln188">                        break;</a>
<a name="ln189">                case CDF_DOUBLE:</a>
<a name="ln190">                        if (NOTMIME(ms) &amp;&amp; file_printf(ms, &quot;, %s: %g&quot;, buf,</a>
<a name="ln191">                            info[i].pi_d) == -1)</a>
<a name="ln192">                                return -1;</a>
<a name="ln193">                        break;</a>
<a name="ln194">                case CDF_LENGTH32_STRING:</a>
<a name="ln195">                case CDF_LENGTH32_WSTRING:</a>
<a name="ln196">                        len = info[i].pi_str.s_len;</a>
<a name="ln197">                        if (len &gt; 1) {</a>
<a name="ln198">                                char vbuf[1024];</a>
<a name="ln199">                                size_t j, k = 1;</a>
<a name="ln200"> </a>
<a name="ln201">                                if (info[i].pi_type == CDF_LENGTH32_WSTRING)</a>
<a name="ln202">                                    k++;</a>
<a name="ln203">                                s = info[i].pi_str.s_buf;</a>
<a name="ln204">				e = info[i].pi_str.s_buf + len;</a>
<a name="ln205">                                for (j = 0; s &lt; e &amp;&amp; j &lt; sizeof(vbuf)</a>
<a name="ln206">				    &amp;&amp; len--; s += k) {</a>
<a name="ln207">                                        if (*s == '\0')</a>
<a name="ln208">                                                break;</a>
<a name="ln209">                                        if (isprint((unsigned char)*s))</a>
<a name="ln210">                                                vbuf[j++] = *s;</a>
<a name="ln211">                                }</a>
<a name="ln212">                                if (j == sizeof(vbuf))</a>
<a name="ln213">                                        --j;</a>
<a name="ln214">                                vbuf[j] = '\0';</a>
<a name="ln215">                                if (NOTMIME(ms)) {</a>
<a name="ln216">                                        if (vbuf[0]) {</a>
<a name="ln217">                                                if (file_printf(ms, &quot;, %s: %s&quot;,</a>
<a name="ln218">                                                    buf, vbuf) == -1)</a>
<a name="ln219">                                                        return -1;</a>
<a name="ln220">                                        }</a>
<a name="ln221">                                } else if (str == NULL &amp;&amp; info[i].pi_id ==</a>
<a name="ln222">				    CDF_PROPERTY_NAME_OF_APPLICATION) {</a>
<a name="ln223">					str = cdf_app_to_mime(vbuf, app2mime);</a>
<a name="ln224">				}</a>
<a name="ln225">			}</a>
<a name="ln226">                        break;</a>
<a name="ln227">                case CDF_FILETIME:</a>
<a name="ln228">                        tp = info[i].pi_tp;</a>
<a name="ln229">                        if (tp != 0) {</a>
<a name="ln230">				char tbuf[64];</a>
<a name="ln231">                                if (tp &lt; 1000000000000000LL) {</a>
<a name="ln232">                                        cdf_print_elapsed_time(tbuf,</a>
<a name="ln233">                                            sizeof(tbuf), tp);</a>
<a name="ln234">                                        if (NOTMIME(ms) &amp;&amp; file_printf(ms,</a>
<a name="ln235">                                            &quot;, %s: %s&quot;, buf, tbuf) == -1)</a>
<a name="ln236">                                                return -1;</a>
<a name="ln237">                                } else {</a>
<a name="ln238">                                        char *c, *ec;</a>
<a name="ln239">                                        cdf_timestamp_to_timespec(&amp;ts, tp);</a>
<a name="ln240">                                        c = cdf_ctime(&amp;ts.tv_sec, tbuf);</a>
<a name="ln241">                                        if (c != NULL &amp;&amp;</a>
<a name="ln242">					    (ec = strchr(c, '\n')) != NULL)</a>
<a name="ln243">						*ec = '\0';</a>
<a name="ln244"> </a>
<a name="ln245">                                        if (NOTMIME(ms) &amp;&amp; file_printf(ms,</a>
<a name="ln246">                                            &quot;, %s: %s&quot;, buf, c) == -1)</a>
<a name="ln247">                                                return -1;</a>
<a name="ln248">                                }</a>
<a name="ln249">                        }</a>
<a name="ln250">                        break;</a>
<a name="ln251">                case CDF_CLIPBOARD:</a>
<a name="ln252">                        break;</a>
<a name="ln253">                default:</a>
<a name="ln254">                        return -1;</a>
<a name="ln255">                }</a>
<a name="ln256">        }</a>
<a name="ln257">        if (!NOTMIME(ms)) {</a>
<a name="ln258">		if (str == NULL)</a>
<a name="ln259">			return 0;</a>
<a name="ln260">                if (file_printf(ms, &quot;application/%s&quot;, str) == -1)</a>
<a name="ln261">                        return -1;</a>
<a name="ln262">        }</a>
<a name="ln263">        return 1;</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">private int</a>
<a name="ln267">cdf_file_catalog(struct magic_set *ms, const cdf_header_t *h,</a>
<a name="ln268">    const cdf_stream_t *sst)</a>
<a name="ln269">{</a>
<a name="ln270">	cdf_catalog_t *cat;</a>
<a name="ln271">	size_t i;</a>
<a name="ln272">	char buf[256];</a>
<a name="ln273">	cdf_catalog_entry_t *ce;</a>
<a name="ln274"> </a>
<a name="ln275">        if (NOTMIME(ms)) {</a>
<a name="ln276">		if (file_printf(ms, &quot;Microsoft Thumbs.db [&quot;) == -1)</a>
<a name="ln277">			return -1;</a>
<a name="ln278">		if (cdf_unpack_catalog(h, sst, &amp;cat) == -1)</a>
<a name="ln279">			return -1;</a>
<a name="ln280">		ce = cat-&gt;cat_e;</a>
<a name="ln281">		/* skip first entry since it has a , or paren */</a>
<a name="ln282">		for (i = 1; i &lt; cat-&gt;cat_num; i++)</a>
<a name="ln283">			if (file_printf(ms, &quot;%s%s&quot;,</a>
<a name="ln284">			    cdf_u16tos8(buf, ce[i].ce_namlen, ce[i].ce_name),</a>
<a name="ln285">			    i == cat-&gt;cat_num - 1 ? &quot;]&quot; : &quot;, &quot;) == -1) {</a>
<a name="ln286">				free(cat);</a>
<a name="ln287">				return -1;</a>
<a name="ln288">			}</a>
<a name="ln289">		free(cat);</a>
<a name="ln290">	} else {</a>
<a name="ln291">		if (file_printf(ms, &quot;application/CDFV2&quot;) == -1)</a>
<a name="ln292">			return -1;</a>
<a name="ln293">	}</a>
<a name="ln294">	return 1;</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297">private int</a>
<a name="ln298">cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,</a>
<a name="ln299">    const cdf_stream_t *sst, const cdf_directory_t *root_storage)</a>
<a name="ln300">{</a>
<a name="ln301">        cdf_summary_info_header_t si;</a>
<a name="ln302">        cdf_property_info_t *info;</a>
<a name="ln303">        size_t count;</a>
<a name="ln304">        int m;</a>
<a name="ln305"> </a>
<a name="ln306">        if (cdf_unpack_summary_info(sst, h, &amp;si, &amp;info, &amp;count) == -1)</a>
<a name="ln307">                return -1;</a>
<a name="ln308"> </a>
<a name="ln309">        if (NOTMIME(ms)) {</a>
<a name="ln310">		const char *str;</a>
<a name="ln311"> </a>
<a name="ln312">                if (file_printf(ms, &quot;Composite Document File V2 Document&quot;)</a>
<a name="ln313">		    == -1)</a>
<a name="ln314">                        return -1;</a>
<a name="ln315"> </a>
<a name="ln316">                if (file_printf(ms, &quot;, %s Endian&quot;,</a>
<a name="ln317">                    si.si_byte_order == 0xfffe ?  &quot;Little&quot; : &quot;Big&quot;) == -1)</a>
<a name="ln318">                        return -2;</a>
<a name="ln319">                switch (si.si_os) {</a>
<a name="ln320">                case 2:</a>
<a name="ln321">                        if (file_printf(ms, &quot;, Os: Windows, Version %d.%d&quot;,</a>
<a name="ln322">                            si.si_os_version &amp; 0xff,</a>
<a name="ln323">                            (uint32_t)si.si_os_version &gt;&gt; 8) == -1)</a>
<a name="ln324">                                return -2;</a>
<a name="ln325">                        break;</a>
<a name="ln326">                case 1:</a>
<a name="ln327">                        if (file_printf(ms, &quot;, Os: MacOS, Version %d.%d&quot;,</a>
<a name="ln328">                            (uint32_t)si.si_os_version &gt;&gt; 8,</a>
<a name="ln329">                            si.si_os_version &amp; 0xff) == -1)</a>
<a name="ln330">                                return -2;</a>
<a name="ln331">                        break;</a>
<a name="ln332">                default:</a>
<a name="ln333">                        if (file_printf(ms, &quot;, Os %d, Version: %d.%d&quot;, si.si_os,</a>
<a name="ln334">                            si.si_os_version &amp; 0xff,</a>
<a name="ln335">                            (uint32_t)si.si_os_version &gt;&gt; 8) == -1)</a>
<a name="ln336">                                return -2;</a>
<a name="ln337">                        break;</a>
<a name="ln338">                }</a>
<a name="ln339">		if (root_storage) {</a>
<a name="ln340">			str = cdf_clsid_to_mime(root_storage-&gt;d_storage_uuid,</a>
<a name="ln341">			    clsid2desc);</a>
<a name="ln342">			if (str) {</a>
<a name="ln343">				if (file_printf(ms, &quot;, %s&quot;, str) == -1)</a>
<a name="ln344">					return -2;</a>
<a name="ln345">			}</a>
<a name="ln346">		}</a>
<a name="ln347">	}</a>
<a name="ln348"> </a>
<a name="ln349">        m = cdf_file_property_info(ms, info, count, root_storage);</a>
<a name="ln350">        free(info);</a>
<a name="ln351"> </a>
<a name="ln352">        return m == -1 ? -2 : m;</a>
<a name="ln353">}</a>
<a name="ln354"> </a>
<a name="ln355">#ifdef notdef</a>
<a name="ln356">private char *</a>
<a name="ln357">format_clsid(char *buf, size_t len, const uint64_t uuid[2]) {</a>
<a name="ln358">	snprintf(buf, len, &quot;%.8&quot; PRIx64 &quot;-%.4&quot; PRIx64 &quot;-%.4&quot; PRIx64 &quot;-%.4&quot; </a>
<a name="ln359">	    PRIx64 &quot;-%.12&quot; PRIx64,</a>
<a name="ln360">	    (uuid[0] &gt;&gt; 32) &amp; (uint64_t)0x000000000ffffffffULL,</a>
<a name="ln361">	    (uuid[0] &gt;&gt; 16) &amp; (uint64_t)0x0000000000000ffffULL,</a>
<a name="ln362">	    (uuid[0] &gt;&gt;  0) &amp; (uint64_t)0x0000000000000ffffULL, </a>
<a name="ln363">	    (uuid[1] &gt;&gt; 48) &amp; (uint64_t)0x0000000000000ffffULL,</a>
<a name="ln364">	    (uuid[1] &gt;&gt;  0) &amp; (uint64_t)0x0000fffffffffffffULL);</a>
<a name="ln365">	return buf;</a>
<a name="ln366">}</a>
<a name="ln367">#endif</a>
<a name="ln368"> </a>
<a name="ln369">private int</a>
<a name="ln370">cdf_file_catalog_info(struct magic_set *ms, const cdf_info_t *info,</a>
<a name="ln371">    const cdf_header_t *h, const cdf_sat_t *sat, const cdf_sat_t *ssat,</a>
<a name="ln372">    const cdf_stream_t *sst, const cdf_dir_t *dir, cdf_stream_t *scn)</a>
<a name="ln373">{</a>
<a name="ln374">	int i;</a>
<a name="ln375"> </a>
<a name="ln376">	if ((i = cdf_read_user_stream(info, h, sat, ssat, sst,</a>
<a name="ln377">	    dir, &quot;Catalog&quot;, scn)) == -1)</a>
<a name="ln378">		return i;</a>
<a name="ln379">#ifdef CDF_DEBUG</a>
<a name="ln380">	cdf_dump_catalog(h, scn);</a>
<a name="ln381">#endif</a>
<a name="ln382">	if ((i = cdf_file_catalog(ms, h, scn)) == -1)</a>
<a name="ln383">		return -1;</a>
<a name="ln384">	return i;</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">private int</a>
<a name="ln388">cdf_check_summary_info(struct magic_set *ms, const cdf_info_t *info,</a>
<a name="ln389">    const cdf_header_t *h, const cdf_sat_t *sat, const cdf_sat_t *ssat,</a>
<a name="ln390">    const cdf_stream_t *sst, const cdf_dir_t *dir, cdf_stream_t *scn,</a>
<a name="ln391">    const cdf_directory_t *root_storage, const char **expn)</a>
<a name="ln392">{</a>
<a name="ln393">	int i;</a>
<a name="ln394">	const char *str = NULL;</a>
<a name="ln395">	cdf_directory_t *d;</a>
<a name="ln396">	char name[__arraycount(d-&gt;d_name)];</a>
<a name="ln397">	size_t j, k;</a>
<a name="ln398"> </a>
<a name="ln399">#ifdef CDF_DEBUG</a>
<a name="ln400">        cdf_dump_summary_info(h, scn);</a>
<a name="ln401">#endif</a>
<a name="ln402">        if ((i = cdf_file_summary_info(ms, h, scn, root_storage)) &lt; 0) {</a>
<a name="ln403">            *expn = &quot;Can't expand summary_info&quot;;</a>
<a name="ln404">	    return i;</a>
<a name="ln405">	}</a>
<a name="ln406">	if (i == 1)</a>
<a name="ln407">		return i;</a>
<a name="ln408">	for (j = 0; str == NULL &amp;&amp; j &lt; dir-&gt;dir_len; j++) {</a>
<a name="ln409">		d = &amp;dir-&gt;dir_tab[j];</a>
<a name="ln410">		for (k = 0; k &lt; sizeof(name); k++)</a>
<a name="ln411">			name[k] = (char)cdf_tole2(d-&gt;d_name[k]);</a>
<a name="ln412">		str = cdf_app_to_mime(name,</a>
<a name="ln413">				      NOTMIME(ms) ? name2desc : name2mime);</a>
<a name="ln414">	}</a>
<a name="ln415">	if (NOTMIME(ms)) {</a>
<a name="ln416">		if (str != NULL) {</a>
<a name="ln417">			if (file_printf(ms, &quot;%s&quot;, str) == -1)</a>
<a name="ln418">				return -1;</a>
<a name="ln419">			i = 1;</a>
<a name="ln420">		}</a>
<a name="ln421">	} else {</a>
<a name="ln422">		if (str == NULL)</a>
<a name="ln423">			str = &quot;vnd.ms-office&quot;;</a>
<a name="ln424">		if (file_printf(ms, &quot;application/%s&quot;, str) == -1)</a>
<a name="ln425">			return -1;</a>
<a name="ln426">		i = 1;</a>
<a name="ln427">	}</a>
<a name="ln428">	if (i &lt;= 0) {</a>
<a name="ln429">		i = cdf_file_catalog_info(ms, info, h, sat, ssat, sst,</a>
<a name="ln430">					  dir, scn);</a>
<a name="ln431">	}</a>
<a name="ln432">	return i;</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">private struct sinfo {</a>
<a name="ln436">	const char *name;</a>
<a name="ln437">	const char *mime;</a>
<a name="ln438">	const char *sections[5];</a>
<a name="ln439">	const int  types[5];</a>
<a name="ln440">} sectioninfo[] = {</a>
<a name="ln441">	{ &quot;Encrypted&quot;, &quot;encrypted&quot;, </a>
<a name="ln442">		{</a>
<a name="ln443">			&quot;EncryptedPackage&quot;, &quot;EncryptedSummary&quot;,</a>
<a name="ln444">			NULL, NULL, NULL,</a>
<a name="ln445">		},</a>
<a name="ln446">		{</a>
<a name="ln447">			CDF_DIR_TYPE_USER_STREAM,</a>
<a name="ln448">			CDF_DIR_TYPE_USER_STREAM,</a>
<a name="ln449">			0, 0, 0,</a>
<a name="ln450"> </a>
<a name="ln451">		},</a>
<a name="ln452">	},</a>
<a name="ln453">	{ &quot;QuickBooks&quot;, &quot;quickbooks&quot;, </a>
<a name="ln454">		{</a>
<a name="ln455">#if 0</a>
<a name="ln456">			&quot;TaxForms&quot;, &quot;PDFTaxForms&quot;, &quot;modulesInBackup&quot;,</a>
<a name="ln457">#endif</a>
<a name="ln458">			&quot;mfbu_header&quot;, NULL, NULL, NULL, NULL,</a>
<a name="ln459">		},</a>
<a name="ln460">		{</a>
<a name="ln461">#if 0</a>
<a name="ln462">			CDF_DIR_TYPE_USER_STORAGE,</a>
<a name="ln463">			CDF_DIR_TYPE_USER_STORAGE,</a>
<a name="ln464">			CDF_DIR_TYPE_USER_STREAM,</a>
<a name="ln465">#endif</a>
<a name="ln466">			CDF_DIR_TYPE_USER_STREAM,</a>
<a name="ln467">			0, 0, 0, 0</a>
<a name="ln468">		},</a>
<a name="ln469">	},</a>
<a name="ln470">	{ &quot;Microsoft Excel&quot;, &quot;vnd.ms-excel&quot;,</a>
<a name="ln471">		{</a>
<a name="ln472">			&quot;Book&quot;, &quot;Workbook&quot;, NULL, NULL, NULL,</a>
<a name="ln473">		},</a>
<a name="ln474">		{</a>
<a name="ln475">			CDF_DIR_TYPE_USER_STREAM,</a>
<a name="ln476">			CDF_DIR_TYPE_USER_STREAM,</a>
<a name="ln477">			0, 0, 0,</a>
<a name="ln478">		},</a>
<a name="ln479">	},</a>
<a name="ln480">	{ &quot;Microsoft Word&quot;, &quot;msword&quot;,</a>
<a name="ln481">		{</a>
<a name="ln482">			&quot;WordDocument&quot;, NULL, NULL, NULL, NULL,</a>
<a name="ln483">		},</a>
<a name="ln484">		{</a>
<a name="ln485">			CDF_DIR_TYPE_USER_STREAM,</a>
<a name="ln486">			0, 0, 0, 0,</a>
<a name="ln487">		},</a>
<a name="ln488">	},</a>
<a name="ln489">	{ &quot;Microsoft PowerPoint&quot;, &quot;vnd.ms-powerpoint&quot;,</a>
<a name="ln490">		{</a>
<a name="ln491">			&quot;PowerPoint&quot;, NULL, NULL, NULL, NULL,</a>
<a name="ln492">		},</a>
<a name="ln493">		{</a>
<a name="ln494">			CDF_DIR_TYPE_USER_STREAM,</a>
<a name="ln495">			0, 0, 0, 0,</a>
<a name="ln496">		},</a>
<a name="ln497">	},</a>
<a name="ln498">	{ &quot;Microsoft Outlook Message&quot;, &quot;vnd.ms-outlook&quot;,</a>
<a name="ln499">		{</a>
<a name="ln500">			&quot;__properties_version1.0&quot;,</a>
<a name="ln501">			&quot;__recip_version1.0_#00000000&quot;,</a>
<a name="ln502">			NULL, NULL, NULL,</a>
<a name="ln503">		},</a>
<a name="ln504">		{</a>
<a name="ln505">			CDF_DIR_TYPE_USER_STREAM,</a>
<a name="ln506">			CDF_DIR_TYPE_USER_STORAGE,</a>
<a name="ln507">			0, 0, 0,</a>
<a name="ln508">		},</a>
<a name="ln509">	},</a>
<a name="ln510">};</a>
<a name="ln511"> </a>
<a name="ln512">private int</a>
<a name="ln513">cdf_file_dir_info(struct magic_set *ms, const cdf_dir_t *dir)</a>
<a name="ln514">{</a>
<a name="ln515">	size_t sd, j;</a>
<a name="ln516"> </a>
<a name="ln517">	for (sd = 0; sd &lt; __arraycount(sectioninfo); sd++) {</a>
<a name="ln518">		const struct sinfo *si = &amp;sectioninfo[sd];</a>
<a name="ln519">		for (j = 0; si-&gt;sections[j]; j++) {</a>
<a name="ln520">			if (cdf_find_stream(dir, si-&gt;sections[j], si-&gt;types[j])</a>
<a name="ln521">			    &gt; 0)</a>
<a name="ln522">				break;</a>
<a name="ln523">#ifdef CDF_DEBUG</a>
<a name="ln524">			fprintf(stderr, &quot;Can't read %s\n&quot;, si-&gt;sections[j]);</a>
<a name="ln525">#endif</a>
<a name="ln526">		}</a>
<a name="ln527">		if (si-&gt;sections[j] == NULL)</a>
<a name="ln528">			continue;</a>
<a name="ln529">		if (NOTMIME(ms)) {</a>
<a name="ln530">			if (file_printf(ms, &quot;CDFV2 %s&quot;, si-&gt;name) == -1)</a>
<a name="ln531">				return -1;</a>
<a name="ln532">		} else {</a>
<a name="ln533">			if (file_printf(ms, &quot;application/%s&quot;, si-&gt;mime) == -1)</a>
<a name="ln534">				return -1;</a>
<a name="ln535">		}</a>
<a name="ln536">		return 1;</a>
<a name="ln537">	}</a>
<a name="ln538">	return -1;</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">protected int</a>
<a name="ln542">file_trycdf(struct magic_set *ms, int fd, const unsigned char *buf,</a>
<a name="ln543">    size_t nbytes)</a>
<a name="ln544">{</a>
<a name="ln545">        cdf_info_t info;</a>
<a name="ln546">        cdf_header_t h;</a>
<a name="ln547">        cdf_sat_t sat, ssat;</a>
<a name="ln548">        cdf_stream_t sst, scn;</a>
<a name="ln549">        cdf_dir_t dir;</a>
<a name="ln550">        int i;</a>
<a name="ln551">        const char *expn = &quot;&quot;;</a>
<a name="ln552">        const cdf_directory_t *root_storage;</a>
<a name="ln553"> </a>
<a name="ln554">        scn.sst_tab = NULL;</a>
<a name="ln555">        info.i_fd = fd;</a>
<a name="ln556">        info.i_buf = buf;</a>
<a name="ln557">        info.i_len = nbytes;</a>
<a name="ln558">        if (ms-&gt;flags &amp; (MAGIC_APPLE|MAGIC_EXTENSION))</a>
<a name="ln559">                return 0;</a>
<a name="ln560">        if (cdf_read_header(&amp;info, &amp;h) == -1)</a>
<a name="ln561">                return 0;</a>
<a name="ln562">#ifdef CDF_DEBUG</a>
<a name="ln563">        cdf_dump_header(&amp;h);</a>
<a name="ln564">#endif</a>
<a name="ln565"> </a>
<a name="ln566">        if ((i = cdf_read_sat(&amp;info, &amp;h, &amp;sat)) == -1) {</a>
<a name="ln567">                expn = &quot;Can't read SAT&quot;;</a>
<a name="ln568">                goto out0;</a>
<a name="ln569">        }</a>
<a name="ln570">#ifdef CDF_DEBUG</a>
<a name="ln571">        cdf_dump_sat(&quot;SAT&quot;, &amp;sat, CDF_SEC_SIZE(&amp;h));</a>
<a name="ln572">#endif</a>
<a name="ln573"> </a>
<a name="ln574">        if ((i = cdf_read_ssat(&amp;info, &amp;h, &amp;sat, &amp;ssat)) == -1) {</a>
<a name="ln575">                expn = &quot;Can't read SSAT&quot;;</a>
<a name="ln576">                goto out1;</a>
<a name="ln577">        }</a>
<a name="ln578">#ifdef CDF_DEBUG</a>
<a name="ln579">        cdf_dump_sat(&quot;SSAT&quot;, &amp;ssat, CDF_SHORT_SEC_SIZE(&amp;h));</a>
<a name="ln580">#endif</a>
<a name="ln581"> </a>
<a name="ln582">        if ((i = cdf_read_dir(&amp;info, &amp;h, &amp;sat, &amp;dir)) == -1) {</a>
<a name="ln583">                expn = &quot;Can't read directory&quot;;</a>
<a name="ln584">                goto out2;</a>
<a name="ln585">        }</a>
<a name="ln586"> </a>
<a name="ln587">        if ((i = cdf_read_short_stream(&amp;info, &amp;h, &amp;sat, &amp;dir, &amp;sst,</a>
<a name="ln588">	    &amp;root_storage)) == -1) {</a>
<a name="ln589">                expn = &quot;Cannot read short stream&quot;;</a>
<a name="ln590">                goto out3;</a>
<a name="ln591">        }</a>
<a name="ln592">#ifdef CDF_DEBUG</a>
<a name="ln593">        cdf_dump_dir(&amp;info, &amp;h, &amp;sat, &amp;ssat, &amp;sst, &amp;dir);</a>
<a name="ln594">#endif</a>
<a name="ln595">#ifdef notdef</a>
<a name="ln596">	if (root_storage) {</a>
<a name="ln597">		if (NOTMIME(ms)) {</a>
<a name="ln598">			char clsbuf[128];</a>
<a name="ln599">			if (file_printf(ms, &quot;CLSID %s, &quot;,</a>
<a name="ln600">			    format_clsid(clsbuf, sizeof(clsbuf),</a>
<a name="ln601">			    root_storage-&gt;d_storage_uuid)) == -1)</a>
<a name="ln602">				return -1;</a>
<a name="ln603">		}</a>
<a name="ln604">	}</a>
<a name="ln605">#endif</a>
<a name="ln606"> </a>
<a name="ln607">	if ((i = cdf_read_user_stream(&amp;info, &amp;h, &amp;sat, &amp;ssat, &amp;sst, &amp;dir,</a>
<a name="ln608">	    &quot;FileHeader&quot;, &amp;scn)) != -1) {</a>
<a name="ln609">#define HWP5_SIGNATURE &quot;HWP Document File&quot;</a>
<a name="ln610">		if (scn.sst_len * scn.sst_ss &gt;= sizeof(HWP5_SIGNATURE) - 1</a>
<a name="ln611">		    &amp;&amp; memcmp(scn.sst_tab, HWP5_SIGNATURE,</a>
<a name="ln612">		    sizeof(HWP5_SIGNATURE) - 1) == 0) {</a>
<a name="ln613">		    if (NOTMIME(ms)) {</a>
<a name="ln614">			if (file_printf(ms,</a>
<a name="ln615">			    &quot;Hangul (Korean) Word Processor File 5.x&quot;) == -1)</a>
<a name="ln616">			    return -1;</a>
<a name="ln617">		    } else {</a>
<a name="ln618">			if (file_printf(ms, &quot;application/x-hwp&quot;) == -1)</a>
<a name="ln619">			    return -1;</a>
<a name="ln620">		    }</a>
<a name="ln621">		    i = 1;</a>
<a name="ln622">		    goto out5;</a>
<a name="ln623">		} else {</a>
<a name="ln624">		    cdf_zero_stream(&amp;scn);</a>
<a name="ln625">		}</a>
<a name="ln626">	}</a>
<a name="ln627"> </a>
<a name="ln628">        if ((i = cdf_read_summary_info(&amp;info, &amp;h, &amp;sat, &amp;ssat, &amp;sst, &amp;dir,</a>
<a name="ln629">            &amp;scn)) == -1) {</a>
<a name="ln630">                if (errno != ESRCH) {</a>
<a name="ln631">                        expn = &quot;Cannot read summary info&quot;;</a>
<a name="ln632">		}</a>
<a name="ln633">	} else {</a>
<a name="ln634">		i = cdf_check_summary_info(ms, &amp;info, &amp;h,</a>
<a name="ln635">		    &amp;sat, &amp;ssat, &amp;sst, &amp;dir, &amp;scn, root_storage, &amp;expn);</a>
<a name="ln636">		cdf_zero_stream(&amp;scn);</a>
<a name="ln637">	}</a>
<a name="ln638">	if (i &lt;= 0) {</a>
<a name="ln639">		if ((i = cdf_read_doc_summary_info(&amp;info, &amp;h, &amp;sat, &amp;ssat,</a>
<a name="ln640">		    &amp;sst, &amp;dir, &amp;scn)) == -1) {</a>
<a name="ln641">			if (errno != ESRCH) {</a>
<a name="ln642">				expn = &quot;Cannot read summary info&quot;;</a>
<a name="ln643">			}</a>
<a name="ln644">		} else {</a>
<a name="ln645">			i = cdf_check_summary_info(ms, &amp;info, &amp;h, &amp;sat, &amp;ssat,</a>
<a name="ln646">			    &amp;sst, &amp;dir, &amp;scn, root_storage, &amp;expn);</a>
<a name="ln647">		}</a>
<a name="ln648">	}</a>
<a name="ln649">	if (i &lt;= 0) {</a>
<a name="ln650">		i = cdf_file_dir_info(ms, &amp;dir);</a>
<a name="ln651">		if (i &lt; 0)</a>
<a name="ln652">			expn = &quot;Cannot read section info&quot;;</a>
<a name="ln653">	}</a>
<a name="ln654">out5:</a>
<a name="ln655">	cdf_zero_stream(&amp;scn);</a>
<a name="ln656">	cdf_zero_stream(&amp;sst);</a>
<a name="ln657">out3:</a>
<a name="ln658">        free(dir.dir_tab);</a>
<a name="ln659">out2:</a>
<a name="ln660">        free(ssat.sat_tab);</a>
<a name="ln661">out1:</a>
<a name="ln662">        free(sat.sat_tab);</a>
<a name="ln663">out0:</a>
<a name="ln664">	if (i == -1) {</a>
<a name="ln665">	    if (NOTMIME(ms)) {</a>
<a name="ln666">		if (file_printf(ms,</a>
<a name="ln667">		    &quot;Composite Document File V2 Document&quot;) == -1)</a>
<a name="ln668">		    return -1;</a>
<a name="ln669">		if (*expn)</a>
<a name="ln670">		    if (file_printf(ms, &quot;, %s&quot;, expn) == -1)</a>
<a name="ln671">			return -1;</a>
<a name="ln672">	    } else {</a>
<a name="ln673">		if (file_printf(ms, &quot;application/CDFV2&quot;) == -1)</a>
<a name="ln674">		    return -1;</a>
<a name="ln675">	    }</a>
<a name="ln676">	    i = 1;</a>
<a name="ln677">	}</a>
<a name="ln678">        return i;</a>
<a name="ln679">}</a>
</code></pre>
<div class="balloon" rel="246"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1004/" target="_blank">V1004</a> The 'c' pointer was used unsafely after it was verified against nullptr. Check lines: 241, 246.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>