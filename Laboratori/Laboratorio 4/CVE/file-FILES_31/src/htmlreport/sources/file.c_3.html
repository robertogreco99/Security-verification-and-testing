<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>file.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com</a>
<a name="ln3">/*</a>
<a name="ln4"> * Copyright (c) Ian F. Darwin 1986-1995.</a>
<a name="ln5"> * Software written by Ian F. Darwin and others;</a>
<a name="ln6"> * maintained 1995-present by Christos Zoulas and others.</a>
<a name="ln7"> *</a>
<a name="ln8"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln9"> * modification, are permitted provided that the following conditions</a>
<a name="ln10"> * are met:</a>
<a name="ln11"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln12"> *    notice immediately at the beginning of the file, without modification,</a>
<a name="ln13"> *    this list of conditions, and the following disclaimer.</a>
<a name="ln14"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln15"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln16"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln17"> *</a>
<a name="ln18"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln19"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln20"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln21"> * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR</a>
<a name="ln22"> * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln23"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln24"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln25"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln26"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln27"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln28"> * SUCH DAMAGE.</a>
<a name="ln29"> */</a>
<a name="ln30">/*</a>
<a name="ln31"> * file - find type of a file or files - main program.</a>
<a name="ln32"> */</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;file.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">#ifndef	lint</a>
<a name="ln37">FILE_RCSID(&quot;@(#)$File: file.c,v 1.171 2016/05/17 15:52:45 christos Exp $&quot;)</a>
<a name="ln38">#endif	/* lint */</a>
<a name="ln39"> </a>
<a name="ln40">#include &quot;magic.h&quot;</a>
<a name="ln41"> </a>
<a name="ln42">#include &lt;stdlib.h&gt;</a>
<a name="ln43">#include &lt;unistd.h&gt;</a>
<a name="ln44">#include &lt;string.h&gt;</a>
<a name="ln45">#ifdef RESTORE_TIME</a>
<a name="ln46"># if (__COHERENT__ &gt;= 0x420)</a>
<a name="ln47">#  include &lt;sys/utime.h&gt;</a>
<a name="ln48"># else</a>
<a name="ln49">#  ifdef USE_UTIMES</a>
<a name="ln50">#   include &lt;sys/time.h&gt;</a>
<a name="ln51">#  else</a>
<a name="ln52">#   include &lt;utime.h&gt;</a>
<a name="ln53">#  endif</a>
<a name="ln54"># endif</a>
<a name="ln55">#endif</a>
<a name="ln56">#ifdef HAVE_UNISTD_H</a>
<a name="ln57">#include &lt;unistd.h&gt;	/* for read() */</a>
<a name="ln58">#endif</a>
<a name="ln59">#ifdef HAVE_WCHAR_H</a>
<a name="ln60">#include &lt;wchar.h&gt;</a>
<a name="ln61">#endif</a>
<a name="ln62"> </a>
<a name="ln63">#if defined(HAVE_GETOPT_H) &amp;&amp; defined(HAVE_STRUCT_OPTION)</a>
<a name="ln64">#include &lt;getopt.h&gt;</a>
<a name="ln65">#ifndef HAVE_GETOPT_LONG</a>
<a name="ln66">int getopt_long(int argc, char * const *argv, const char *optstring, const struct option *longopts, int *longindex);</a>
<a name="ln67">#endif</a>
<a name="ln68">#else</a>
<a name="ln69">#include &quot;mygetopt.h&quot;</a>
<a name="ln70">#endif</a>
<a name="ln71"> </a>
<a name="ln72">#ifdef S_IFLNK</a>
<a name="ln73">#define FILE_FLAGS &quot;-bcEhikLlNnprsvzZ0&quot;</a>
<a name="ln74">#else</a>
<a name="ln75">#define FILE_FLAGS &quot;-bcEiklNnprsvzZ0&quot;</a>
<a name="ln76">#endif</a>
<a name="ln77"> </a>
<a name="ln78"># define USAGE  \</a>
<a name="ln79">    &quot;Usage: %s [&quot; FILE_FLAGS \</a>
<a name="ln80">	&quot;] [--apple] [--extension] [--mime-encoding] [--mime-type]\n&quot; \</a>
<a name="ln81">    &quot;            [-e testname] [-F separator] [-f namefile] [-m magicfiles] &quot; \</a>
<a name="ln82">    &quot;file ...\n&quot; \</a>
<a name="ln83">    &quot;       %s -C [-m magicfiles]\n&quot; \</a>
<a name="ln84">    &quot;       %s [--help]\n&quot;</a>
<a name="ln85"> </a>
<a name="ln86">private int 		/* Global command-line options 		*/</a>
<a name="ln87">	bflag = 0,	/* brief output format	 		*/</a>
<a name="ln88">	nopad = 0,	/* Don't pad output			*/</a>
<a name="ln89">	nobuffer = 0,   /* Do not buffer stdout 		*/</a>
<a name="ln90">	nulsep = 0;	/* Append '\0' to the separator		*/</a>
<a name="ln91"> </a>
<a name="ln92">private const char *separator = &quot;:&quot;;	/* Default field separator	*/</a>
<a name="ln93">private const struct option long_options[] = {</a>
<a name="ln94">#define OPT_HELP		1</a>
<a name="ln95">#define OPT_APPLE		2</a>
<a name="ln96">#define OPT_EXTENSIONS		3</a>
<a name="ln97">#define OPT_MIME_TYPE		4</a>
<a name="ln98">#define OPT_MIME_ENCODING	5</a>
<a name="ln99">#define OPT(shortname, longname, opt, def, doc)      \</a>
<a name="ln100">    {longname, opt, NULL, shortname},</a>
<a name="ln101">#define OPT_LONGONLY(longname, opt, def, doc, id)        \</a>
<a name="ln102">    {longname, opt, NULL, id},</a>
<a name="ln103">#include &quot;file_opts.h&quot;</a>
<a name="ln104">#undef OPT</a>
<a name="ln105">#undef OPT_LONGONLY</a>
<a name="ln106">    {0, 0, NULL, 0}</a>
<a name="ln107">};</a>
<a name="ln108">#define OPTSTRING	&quot;bcCde:Ef:F:hiklLm:nNpP:rsvzZ0&quot;</a>
<a name="ln109"> </a>
<a name="ln110">private const struct {</a>
<a name="ln111">	const char *name;</a>
<a name="ln112">	int value;</a>
<a name="ln113">} nv[] = {</a>
<a name="ln114">	{ &quot;apptype&quot;,	MAGIC_NO_CHECK_APPTYPE },</a>
<a name="ln115">	{ &quot;ascii&quot;,	MAGIC_NO_CHECK_ASCII },</a>
<a name="ln116">	{ &quot;cdf&quot;,	MAGIC_NO_CHECK_CDF },</a>
<a name="ln117">	{ &quot;compress&quot;,	MAGIC_NO_CHECK_COMPRESS },</a>
<a name="ln118">	{ &quot;elf&quot;,	MAGIC_NO_CHECK_ELF },</a>
<a name="ln119">	{ &quot;encoding&quot;,	MAGIC_NO_CHECK_ENCODING },</a>
<a name="ln120">	{ &quot;soft&quot;,	MAGIC_NO_CHECK_SOFT },</a>
<a name="ln121">	{ &quot;tar&quot;,	MAGIC_NO_CHECK_TAR },</a>
<a name="ln122">	{ &quot;text&quot;,	MAGIC_NO_CHECK_TEXT },	/* synonym for ascii */</a>
<a name="ln123">	{ &quot;tokens&quot;,	MAGIC_NO_CHECK_TOKENS }, /* OBSOLETE: ignored for backwards compatibility */</a>
<a name="ln124">};</a>
<a name="ln125"> </a>
<a name="ln126">private struct {</a>
<a name="ln127">	const char *name;</a>
<a name="ln128">	int tag;</a>
<a name="ln129">	size_t value;</a>
<a name="ln130">} pm[] = {</a>
<a name="ln131">	{ &quot;indir&quot;,	MAGIC_PARAM_INDIR_MAX, 0 },</a>
<a name="ln132">	{ &quot;name&quot;,	MAGIC_PARAM_NAME_MAX, 0 },</a>
<a name="ln133">	{ &quot;elf_phnum&quot;,	MAGIC_PARAM_ELF_PHNUM_MAX, 0 },</a>
<a name="ln134">	{ &quot;elf_shnum&quot;,	MAGIC_PARAM_ELF_SHNUM_MAX, 0 },</a>
<a name="ln135">	{ &quot;elf_notes&quot;,	MAGIC_PARAM_ELF_NOTES_MAX, 0 },</a>
<a name="ln136">	{ &quot;regex&quot;,	MAGIC_PARAM_REGEX_MAX, 0 },</a>
<a name="ln137">	{ &quot;bytes&quot;,	MAGIC_PARAM_BYTES_MAX, 0 },</a>
<a name="ln138">};</a>
<a name="ln139"> </a>
<a name="ln140">private char *progname;		/* used throughout 		*/</a>
<a name="ln141">private int posixly;</a>
<a name="ln142"> </a>
<a name="ln143">#ifdef __dead</a>
<a name="ln144">__dead</a>
<a name="ln145">#endif</a>
<a name="ln146">private void usage(void);</a>
<a name="ln147">private void docprint(const char *, int);</a>
<a name="ln148">#ifdef __dead</a>
<a name="ln149">__dead</a>
<a name="ln150">#endif</a>
<a name="ln151">private void help(void);</a>
<a name="ln152"> </a>
<a name="ln153">private int unwrap(struct magic_set *, const char *);</a>
<a name="ln154">private int process(struct magic_set *ms, const char *, int);</a>
<a name="ln155">private struct magic_set *load(const char *, int);</a>
<a name="ln156">private void setparam(const char *);</a>
<a name="ln157">private void applyparam(magic_t);</a>
<a name="ln158"> </a>
<a name="ln159"> </a>
<a name="ln160">/*</a>
<a name="ln161"> * main - parse arguments and handle options</a>
<a name="ln162"> */</a>
<a name="ln163">int</a>
<a name="ln164">main(int argc, char *argv[])</a>
<a name="ln165">{</a>
<a name="ln166">	int c;</a>
<a name="ln167">	size_t i;</a>
<a name="ln168">	int action = 0, didsomefiles = 0, errflg = 0;</a>
<a name="ln169">	int flags = 0, e = 0;</a>
<a name="ln170">	struct magic_set *magic = NULL;</a>
<a name="ln171">	int longindex;</a>
<a name="ln172">	const char *magicfile = NULL;		/* where the magic is	*/</a>
<a name="ln173"> </a>
<a name="ln174">	/* makes islower etc work for other langs */</a>
<a name="ln175">#ifdef HAVE_SETLOCALE</a>
<a name="ln176">	(void)setlocale(LC_CTYPE, &quot;&quot;);</a>
<a name="ln177">#endif</a>
<a name="ln178"> </a>
<a name="ln179">#ifdef __EMX__</a>
<a name="ln180">	/* sh-like wildcard expansion! Shouldn't hurt at least ... */</a>
<a name="ln181">	_wildcard(&amp;argc, &amp;argv);</a>
<a name="ln182">#endif</a>
<a name="ln183"> </a>
<a name="ln184">	if ((progname = strrchr(argv[0], '/')) != NULL)</a>
<a name="ln185">		progname++;</a>
<a name="ln186">	else</a>
<a name="ln187">		progname = argv[0];</a>
<a name="ln188"> </a>
<a name="ln189">#ifdef S_IFLNK</a>
<a name="ln190">	posixly = getenv(&quot;POSIXLY_CORRECT&quot;) != NULL;</a>
<a name="ln191">	flags |=  posixly ? MAGIC_SYMLINK : 0;</a>
<a name="ln192">#endif</a>
<a name="ln193">	while ((c = getopt_long(argc, argv, OPTSTRING, long_options,</a>
<a name="ln194">	    &amp;longindex)) != -1)</a>
<a name="ln195">		switch (c) {</a>
<a name="ln196">		case OPT_HELP:</a>
<a name="ln197">			help();</a>
<a name="ln198">			break;</a>
<a name="ln199">		case OPT_APPLE:</a>
<a name="ln200">			flags |= MAGIC_APPLE;</a>
<a name="ln201">			break;</a>
<a name="ln202">		case OPT_EXTENSIONS:</a>
<a name="ln203">			flags |= MAGIC_EXTENSION;</a>
<a name="ln204">			break;</a>
<a name="ln205">		case OPT_MIME_TYPE:</a>
<a name="ln206">			flags |= MAGIC_MIME_TYPE;</a>
<a name="ln207">			break;</a>
<a name="ln208">		case OPT_MIME_ENCODING:</a>
<a name="ln209">			flags |= MAGIC_MIME_ENCODING;</a>
<a name="ln210">			break;</a>
<a name="ln211">		case '0':</a>
<a name="ln212">			nulsep++;</a>
<a name="ln213">			break;</a>
<a name="ln214">		case 'b':</a>
<a name="ln215">			bflag++;</a>
<a name="ln216">			break;</a>
<a name="ln217">		case 'c':</a>
<a name="ln218">			action = FILE_CHECK;</a>
<a name="ln219">			break;</a>
<a name="ln220">		case 'C':</a>
<a name="ln221">			action = FILE_COMPILE;</a>
<a name="ln222">			break;</a>
<a name="ln223">		case 'd':</a>
<a name="ln224">			flags |= MAGIC_DEBUG|MAGIC_CHECK;</a>
<a name="ln225">			break;</a>
<a name="ln226">		case 'E':</a>
<a name="ln227">			flags |= MAGIC_ERROR;</a>
<a name="ln228">			break;</a>
<a name="ln229">		case 'e':</a>
<a name="ln230">			for (i = 0; i &lt; sizeof(nv) / sizeof(nv[0]); i++)</a>
<a name="ln231">				if (strcmp(nv[i].name, optarg) == 0)</a>
<a name="ln232">					break;</a>
<a name="ln233"> </a>
<a name="ln234">			if (i == sizeof(nv) / sizeof(nv[0]))</a>
<a name="ln235">				errflg++;</a>
<a name="ln236">			else</a>
<a name="ln237">				flags |= nv[i].value;</a>
<a name="ln238">			break;</a>
<a name="ln239"> </a>
<a name="ln240">		case 'f':</a>
<a name="ln241">			if(action)</a>
<a name="ln242">				usage();</a>
<a name="ln243">			if (magic == NULL)</a>
<a name="ln244">				if ((magic = load(magicfile, flags)) == NULL)</a>
<a name="ln245">					return 1;</a>
<a name="ln246">			applyparam(magic);</a>
<a name="ln247">			e |= unwrap(magic, optarg);</a>
<a name="ln248">			++didsomefiles;</a>
<a name="ln249">			break;</a>
<a name="ln250">		case 'F':</a>
<a name="ln251">			separator = optarg;</a>
<a name="ln252">			break;</a>
<a name="ln253">		case 'i':</a>
<a name="ln254">			flags |= MAGIC_MIME;</a>
<a name="ln255">			break;</a>
<a name="ln256">		case 'k':</a>
<a name="ln257">			flags |= MAGIC_CONTINUE;</a>
<a name="ln258">			break;</a>
<a name="ln259">		case 'l':</a>
<a name="ln260">			action = FILE_LIST;</a>
<a name="ln261">			break;</a>
<a name="ln262">		case 'm':</a>
<a name="ln263">			magicfile = optarg;</a>
<a name="ln264">			break;</a>
<a name="ln265">		case 'n':</a>
<a name="ln266">			++nobuffer;</a>
<a name="ln267">			break;</a>
<a name="ln268">		case 'N':</a>
<a name="ln269">			++nopad;</a>
<a name="ln270">			break;</a>
<a name="ln271">#if defined(HAVE_UTIME) || defined(HAVE_UTIMES)</a>
<a name="ln272">		case 'p':</a>
<a name="ln273">			flags |= MAGIC_PRESERVE_ATIME;</a>
<a name="ln274">			break;</a>
<a name="ln275">#endif</a>
<a name="ln276">		case 'P':</a>
<a name="ln277">			setparam(optarg);</a>
<a name="ln278">			break;</a>
<a name="ln279">		case 'r':</a>
<a name="ln280">			flags |= MAGIC_RAW;</a>
<a name="ln281">			break;</a>
<a name="ln282">		case 's':</a>
<a name="ln283">			flags |= MAGIC_DEVICES;</a>
<a name="ln284">			break;</a>
<a name="ln285">		case 'v':</a>
<a name="ln286">			if (magicfile == NULL)</a>
<a name="ln287">				magicfile = magic_getpath(magicfile, action);</a>
<a name="ln288">			(void)fprintf(stdout, &quot;%s-%s\n&quot;, progname, VERSION);</a>
<a name="ln289">			(void)fprintf(stdout, &quot;magic file from %s\n&quot;,</a>
<a name="ln290">				       magicfile);</a>
<a name="ln291">			return 0;</a>
<a name="ln292">		case 'z':</a>
<a name="ln293">			flags |= MAGIC_COMPRESS;</a>
<a name="ln294">			break;</a>
<a name="ln295"> </a>
<a name="ln296">		case 'Z':</a>
<a name="ln297">			flags |= MAGIC_COMPRESS|MAGIC_COMPRESS_TRANSP;</a>
<a name="ln298">			break;</a>
<a name="ln299">#ifdef S_IFLNK</a>
<a name="ln300">		case 'L':</a>
<a name="ln301">			flags |= MAGIC_SYMLINK;</a>
<a name="ln302">			break;</a>
<a name="ln303">		case 'h':</a>
<a name="ln304">			flags &amp;= ~MAGIC_SYMLINK;</a>
<a name="ln305">			break;</a>
<a name="ln306">#endif</a>
<a name="ln307">		case '?':</a>
<a name="ln308">		default:</a>
<a name="ln309">			errflg++;</a>
<a name="ln310">			break;</a>
<a name="ln311">		}</a>
<a name="ln312"> </a>
<a name="ln313">	if (errflg) {</a>
<a name="ln314">		usage();</a>
<a name="ln315">	}</a>
<a name="ln316">	if (e)</a>
<a name="ln317">		return e;</a>
<a name="ln318"> </a>
<a name="ln319">	if (MAGIC_VERSION != magic_version())</a>
<a name="ln320">		(void)fprintf(stderr, &quot;%s: compiled magic version [%d] &quot;</a>
<a name="ln321">		    &quot;does not match with shared library magic version [%d]\n&quot;,</a>
<a name="ln322">		    progname, MAGIC_VERSION, magic_version());</a>
<a name="ln323"> </a>
<a name="ln324">	switch(action) {</a>
<a name="ln325">	case FILE_CHECK:</a>
<a name="ln326">	case FILE_COMPILE:</a>
<a name="ln327">	case FILE_LIST:</a>
<a name="ln328">		/*</a>
<a name="ln329">		 * Don't try to check/compile ~/.magic unless we explicitly</a>
<a name="ln330">		 * ask for it.</a>
<a name="ln331">		 */</a>
<a name="ln332">		magic = magic_open(flags|MAGIC_CHECK);</a>
<a name="ln333">		if (magic == NULL) {</a>
<a name="ln334">			(void)fprintf(stderr, &quot;%s: %s\n&quot;, progname,</a>
<a name="ln335">			    strerror(errno));</a>
<a name="ln336">			return 1;</a>
<a name="ln337">		}</a>
<a name="ln338"> </a>
<a name="ln339"> </a>
<a name="ln340">		switch(action) {</a>
<a name="ln341">		case FILE_CHECK:</a>
<a name="ln342">			c = magic_check(magic, magicfile);</a>
<a name="ln343">			break;</a>
<a name="ln344">		case FILE_COMPILE:</a>
<a name="ln345">			c = magic_compile(magic, magicfile);</a>
<a name="ln346">			break;</a>
<a name="ln347">		case FILE_LIST:</a>
<a name="ln348">			c = magic_list(magic, magicfile);</a>
<a name="ln349">			break;</a>
<a name="ln350">		default:</a>
<a name="ln351">			abort();</a>
<a name="ln352">		}</a>
<a name="ln353">		if (c == -1) {</a>
<a name="ln354">			(void)fprintf(stderr, &quot;%s: %s\n&quot;, progname,</a>
<a name="ln355">			    magic_error(magic));</a>
<a name="ln356">			e = 1;</a>
<a name="ln357">			goto out;</a>
<a name="ln358">		}</a>
<a name="ln359">		goto out;</a>
<a name="ln360">	default:</a>
<a name="ln361">		if (magic == NULL)</a>
<a name="ln362">			if ((magic = load(magicfile, flags)) == NULL)</a>
<a name="ln363">				return 1;</a>
<a name="ln364">		applyparam(magic);</a>
<a name="ln365">	}</a>
<a name="ln366"> </a>
<a name="ln367">	if (optind == argc) {</a>
<a name="ln368">		if (!didsomefiles)</a>
<a name="ln369">			usage();</a>
<a name="ln370">	}</a>
<a name="ln371">	else {</a>
<a name="ln372">		size_t j, wid, nw;</a>
<a name="ln373">		for (wid = 0, j = (size_t)optind; j &lt; (size_t)argc; j++) {</a>
<a name="ln374">			nw = file_mbswidth(argv[j]);</a>
<a name="ln375">			if (nw &gt; wid)</a>
<a name="ln376">				wid = nw;</a>
<a name="ln377">		}</a>
<a name="ln378">		/*</a>
<a name="ln379">		 * If bflag is only set twice, set it depending on</a>
<a name="ln380">		 * number of files [this is undocumented, and subject to change]</a>
<a name="ln381">		 */</a>
<a name="ln382">		if (bflag == 2) {</a>
<a name="ln383">			bflag = optind &gt;= argc - 1;</a>
<a name="ln384">		}</a>
<a name="ln385">		for (; optind &lt; argc; optind++)</a>
<a name="ln386">			e |= process(magic, argv[optind], wid);</a>
<a name="ln387">	}</a>
<a name="ln388"> </a>
<a name="ln389">out:</a>
<a name="ln390">	if (magic)</a>
<a name="ln391">		magic_close(magic);</a>
<a name="ln392">	return e;</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">private void</a>
<a name="ln396">applyparam(magic_t magic)</a>
<a name="ln397">{</a>
<a name="ln398">	size_t i;</a>
<a name="ln399"> </a>
<a name="ln400">	for (i = 0; i &lt; __arraycount(pm); i++) {</a>
<a name="ln401">		if (pm[i].value == 0)</a>
<a name="ln402">			continue;</a>
<a name="ln403">		if (magic_setparam(magic, pm[i].tag, &amp;pm[i].value) == -1) {</a>
<a name="ln404">			(void)fprintf(stderr, &quot;%s: Can't set %s %s\n&quot;, progname,</a>
<a name="ln405">				pm[i].name, strerror(errno));</a>
<a name="ln406">			exit(1);</a>
<a name="ln407">		}</a>
<a name="ln408">	}</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411">private void</a>
<a name="ln412">setparam(const char *p)</a>
<a name="ln413">{</a>
<a name="ln414">	size_t i;</a>
<a name="ln415">	char *s;</a>
<a name="ln416"> </a>
<a name="ln417">	if ((s = strchr(p, '=')) == NULL)</a>
<a name="ln418">		goto badparm;</a>
<a name="ln419"> </a>
<a name="ln420">	for (i = 0; i &lt; __arraycount(pm); i++) {</a>
<a name="ln421">		if (strncmp(p, pm[i].name, s - p) != 0)</a>
<a name="ln422">			continue;</a>
<a name="ln423">		pm[i].value = atoi(s + 1);</a>
<a name="ln424">		return;</a>
<a name="ln425">	}</a>
<a name="ln426">badparm:</a>
<a name="ln427">	(void)fprintf(stderr, &quot;%s: Unknown param %s\n&quot;, progname, p);</a>
<a name="ln428">	exit(1);</a>
<a name="ln429">}</a>
<a name="ln430"> </a>
<a name="ln431">private struct magic_set *</a>
<a name="ln432">/*ARGSUSED*/</a>
<a name="ln433">load(const char *magicfile, int flags)</a>
<a name="ln434">{</a>
<a name="ln435">	struct magic_set *magic = magic_open(flags);</a>
<a name="ln436">	const char *e;</a>
<a name="ln437"> </a>
<a name="ln438">	if (magic == NULL) {</a>
<a name="ln439">		(void)fprintf(stderr, &quot;%s: %s\n&quot;, progname, strerror(errno));</a>
<a name="ln440">		return NULL;</a>
<a name="ln441">	}</a>
<a name="ln442">	if (magic_load(magic, magicfile) == -1) {</a>
<a name="ln443">		(void)fprintf(stderr, &quot;%s: %s\n&quot;,</a>
<a name="ln444">		    progname, magic_error(magic));</a>
<a name="ln445">		magic_close(magic);</a>
<a name="ln446">		return NULL;</a>
<a name="ln447">	}</a>
<a name="ln448">	if ((e = magic_error(magic)) != NULL)</a>
<a name="ln449">		(void)fprintf(stderr, &quot;%s: Warning: %s\n&quot;, progname, e);</a>
<a name="ln450">	return magic;</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">/*</a>
<a name="ln454"> * unwrap -- read a file of filenames, do each one.</a>
<a name="ln455"> */</a>
<a name="ln456">private int</a>
<a name="ln457">unwrap(struct magic_set *ms, const char *fn)</a>
<a name="ln458">{</a>
<a name="ln459">	FILE *f;</a>
<a name="ln460">	ssize_t len;</a>
<a name="ln461">	char *line = NULL;</a>
<a name="ln462">	size_t llen = 0;</a>
<a name="ln463">	int wid = 0, cwid;</a>
<a name="ln464">	int e = 0;</a>
<a name="ln465"> </a>
<a name="ln466">	if (strcmp(&quot;-&quot;, fn) == 0) {</a>
<a name="ln467">		f = stdin;</a>
<a name="ln468">		wid = 1;</a>
<a name="ln469">	} else {</a>
<a name="ln470">		if ((f = fopen(fn, &quot;r&quot;)) == NULL) {</a>
<a name="ln471">			(void)fprintf(stderr, &quot;%s: Cannot open `%s' (%s).\n&quot;,</a>
<a name="ln472">			    progname, fn, strerror(errno));</a>
<a name="ln473">			return 1;</a>
<a name="ln474">		}</a>
<a name="ln475"> </a>
<a name="ln476">		while ((len = getline(&amp;line, &amp;llen, f)) &gt; 0) {</a>
<a name="ln477">			if (line[len - 1] == '\n')</a>
<a name="ln478">				line[len - 1] = '\0';</a>
<a name="ln479">			cwid = file_mbswidth(line);</a>
<a name="ln480">			if (cwid &gt; wid)</a>
<a name="ln481">				wid = cwid;</a>
<a name="ln482">		}</a>
<a name="ln483"> </a>
<a name="ln484">		rewind(f);</a>
<a name="ln485">	}</a>
<a name="ln486"> </a>
<a name="ln487">	while ((len = getline(&amp;line, &amp;llen, f)) &gt; 0) {</a>
<a name="ln488">		if (line[len - 1] == '\n')</a>
<a name="ln489">			line[len - 1] = '\0';</a>
<a name="ln490">		e |= process(ms, line, wid);</a>
<a name="ln491">		if(nobuffer)</a>
<a name="ln492">			(void)fflush(stdout);</a>
<a name="ln493">	}</a>
<a name="ln494"> </a>
<a name="ln495">	free(line);</a>
<a name="ln496">	(void)fclose(f);</a>
<a name="ln497">	return e;</a>
<a name="ln498">}</a>
<a name="ln499"> </a>
<a name="ln500">/*</a>
<a name="ln501"> * Called for each input file on the command line (or in a list of files)</a>
<a name="ln502"> */</a>
<a name="ln503">private int</a>
<a name="ln504">process(struct magic_set *ms, const char *inname, int wid)</a>
<a name="ln505">{</a>
<a name="ln506">	const char *type, c = nulsep &gt; 1 ? '\0' : '\n';</a>
<a name="ln507">	int std_in = strcmp(inname, &quot;-&quot;) == 0;</a>
<a name="ln508"> </a>
<a name="ln509">	if (wid &gt; 0 &amp;&amp; !bflag) {</a>
<a name="ln510">		(void)printf(&quot;%s&quot;, std_in ? &quot;/dev/stdin&quot; : inname);</a>
<a name="ln511">		if (nulsep)</a>
<a name="ln512">			(void)putc('\0', stdout);</a>
<a name="ln513">		if (nulsep &lt; 2) {</a>
<a name="ln514">			(void)printf(&quot;%s&quot;, separator);</a>
<a name="ln515">			(void)printf(&quot;%*s &quot;,</a>
<a name="ln516">			    (int) (nopad ? 0 : (wid - file_mbswidth(inname))),</a>
<a name="ln517">			    &quot;&quot;);</a>
<a name="ln518">		}</a>
<a name="ln519">	}</a>
<a name="ln520"> </a>
<a name="ln521">	type = magic_file(ms, std_in ? NULL : inname);</a>
<a name="ln522"> </a>
<a name="ln523">	if (type == NULL) {</a>
<a name="ln524">		(void)printf(&quot;ERROR: %s%c&quot;, magic_error(ms), c);</a>
<a name="ln525">		return 1;</a>
<a name="ln526">	} else {</a>
<a name="ln527">		(void)printf(&quot;%s%c&quot;, type, c);</a>
<a name="ln528">		return 0;</a>
<a name="ln529">	}</a>
<a name="ln530">}</a>
<a name="ln531"> </a>
<a name="ln532">protected size_t</a>
<a name="ln533">file_mbswidth(const char *s)</a>
<a name="ln534">{</a>
<a name="ln535">#if defined(HAVE_WCHAR_H) &amp;&amp; defined(HAVE_MBRTOWC) &amp;&amp; defined(HAVE_WCWIDTH)</a>
<a name="ln536">	size_t bytesconsumed, old_n, n, width = 0;</a>
<a name="ln537">	mbstate_t state;</a>
<a name="ln538">	wchar_t nextchar;</a>
<a name="ln539">	(void)memset(&amp;state, 0, sizeof(mbstate_t));</a>
<a name="ln540">	old_n = n = strlen(s);</a>
<a name="ln541"> </a>
<a name="ln542">	while (n &gt; 0) {</a>
<a name="ln543">		bytesconsumed = mbrtowc(&amp;nextchar, s, n, &amp;state);</a>
<a name="ln544">		if (bytesconsumed == (size_t)(-1) ||</a>
<a name="ln545">		    bytesconsumed == (size_t)(-2)) {</a>
<a name="ln546">			/* Something went wrong, return something reasonable */</a>
<a name="ln547">			return old_n;</a>
<a name="ln548">		}</a>
<a name="ln549">		if (s[0] == '\n') {</a>
<a name="ln550">			/*</a>
<a name="ln551">			 * do what strlen() would do, so that caller</a>
<a name="ln552">			 * is always right</a>
<a name="ln553">			 */</a>
<a name="ln554">			width++;</a>
<a name="ln555">		} else {</a>
<a name="ln556">			int w = wcwidth(nextchar);</a>
<a name="ln557">			if (w &gt; 0)</a>
<a name="ln558">				width += w;</a>
<a name="ln559">		}</a>
<a name="ln560"> </a>
<a name="ln561">		s += bytesconsumed, n -= bytesconsumed;</a>
<a name="ln562">	}</a>
<a name="ln563">	return width;</a>
<a name="ln564">#else</a>
<a name="ln565">	return strlen(s);</a>
<a name="ln566">#endif</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569">private void</a>
<a name="ln570">usage(void)</a>
<a name="ln571">{</a>
<a name="ln572">	(void)fprintf(stderr, USAGE, progname, progname, progname);</a>
<a name="ln573">	exit(1);</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">private void</a>
<a name="ln577">defprint(int def)</a>
<a name="ln578">{</a>
<a name="ln579">	if (!def)</a>
<a name="ln580">		return;</a>
<a name="ln581">	if (((def &amp; 1) &amp;&amp; posixly) || ((def &amp; 2) &amp;&amp; !posixly))</a>
<a name="ln582">		fprintf(stdout, &quot; (default)&quot;);</a>
<a name="ln583">	fputc('\n', stdout);</a>
<a name="ln584">}</a>
<a name="ln585"> </a>
<a name="ln586">private void</a>
<a name="ln587">docprint(const char *opts, int def)</a>
<a name="ln588">{</a>
<a name="ln589">	size_t i;</a>
<a name="ln590">	int comma;</a>
<a name="ln591">	char *sp, *p;</a>
<a name="ln592"> </a>
<a name="ln593">	p = strstr(opts, &quot;%o&quot;);</a>
<a name="ln594">	if (p == NULL) {</a>
<a name="ln595">		fprintf(stdout, &quot;%s&quot;, opts);</a>
<a name="ln596">		defprint(def);</a>
<a name="ln597">		return;</a>
<a name="ln598">	}</a>
<a name="ln599"> </a>
<a name="ln600">	for (sp = p - 1; sp &gt; opts &amp;&amp; *sp == ' '; sp--)</a>
<a name="ln601">		continue;</a>
<a name="ln602"> </a>
<a name="ln603">	fprintf(stdout, &quot;%.*s&quot;, (int)(p - opts), opts);</a>
<a name="ln604"> </a>
<a name="ln605">	comma = 0;</a>
<a name="ln606">	for (i = 0; i &lt; __arraycount(nv); i++) {</a>
<a name="ln607">		fprintf(stdout, &quot;%s%s&quot;, comma++ ? &quot;, &quot; : &quot;&quot;, nv[i].name);</a>
<a name="ln608">		if (i &amp;&amp; i % 5 == 0) {</a>
<a name="ln609">			fprintf(stdout, &quot;,\n%*s&quot;, (int)(p - sp - 1), &quot;&quot;);</a>
<a name="ln610">			comma = 0;</a>
<a name="ln611">		}</a>
<a name="ln612">	}</a>
<a name="ln613"> </a>
<a name="ln614">	fprintf(stdout, &quot;%s&quot;, opts + (p - opts) + 2);</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617">private void</a>
<a name="ln618">help(void)</a>
<a name="ln619">{</a>
<a name="ln620">	(void)fputs(</a>
<a name="ln621">&quot;Usage: file [OPTION...] [FILE...]\n&quot;</a>
<a name="ln622">&quot;Determine type of FILEs.\n&quot;</a>
<a name="ln623">&quot;\n&quot;, stdout);</a>
<a name="ln624">#define OPT(shortname, longname, opt, def, doc)      \</a>
<a name="ln625">	fprintf(stdout, &quot;  -%c, --&quot; longname, shortname), \</a>
<a name="ln626">	docprint(doc, def);</a>
<a name="ln627">#define OPT_LONGONLY(longname, opt, def, doc, id)        \</a>
<a name="ln628">	fprintf(stdout, &quot;      --&quot; longname),	\</a>
<a name="ln629">	docprint(doc, def);</a>
<a name="ln630">#include &quot;file_opts.h&quot;</a>
<a name="ln631">#undef OPT</a>
<a name="ln632">#undef OPT_LONGONLY</a>
<a name="ln633">	fprintf(stdout, &quot;\nReport bugs to http://bugs.gw.com/\n&quot;);</a>
<a name="ln634">	exit(0);</a>
<a name="ln635">}</a>
</code></pre>
<div class="balloon" rel="390"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'magic' is always true.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>