<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>file.h</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (c) Ian F. Darwin 1986-1995.</a>
<a name="ln3"> * Software written by Ian F. Darwin and others;</a>
<a name="ln4"> * maintained 1995-present by Christos Zoulas and others.</a>
<a name="ln5"> *</a>
<a name="ln6"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln7"> * modification, are permitted provided that the following conditions</a>
<a name="ln8"> * are met:</a>
<a name="ln9"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln10"> *    notice immediately at the beginning of the file, without modification,</a>
<a name="ln11"> *    this list of conditions, and the following disclaimer.</a>
<a name="ln12"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln13"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln14"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln15"> *</a>
<a name="ln16"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln17"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln18"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln19"> * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR</a>
<a name="ln20"> * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln21"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln22"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln23"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln24"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln25"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln26"> * SUCH DAMAGE.</a>
<a name="ln27"> */</a>
<a name="ln28">/*</a>
<a name="ln29"> * file.h - definitions for file(1) program</a>
<a name="ln30"> * @(#)$File: file.h,v 1.182 2017/04/07 19:46:44 christos Exp $</a>
<a name="ln31"> */</a>
<a name="ln32"> </a>
<a name="ln33">#ifndef __file_h__</a>
<a name="ln34">#define __file_h__</a>
<a name="ln35"> </a>
<a name="ln36">#ifdef HAVE_CONFIG_H</a>
<a name="ln37">#include &lt;config.h&gt;</a>
<a name="ln38">#endif</a>
<a name="ln39">#ifdef HAVE_STDINT_H</a>
<a name="ln40">#ifndef __STDC_LIMIT_MACROS</a>
<a name="ln41">#define __STDC_LIMIT_MACROS</a>
<a name="ln42">#endif</a>
<a name="ln43"> </a>
<a name="ln44">#ifdef WIN32</a>
<a name="ln45">  #ifdef _WIN64</a>
<a name="ln46">    #define SIZE_T_FORMAT &quot;I64&quot;</a>
<a name="ln47">  #else</a>
<a name="ln48">    #define SIZE_T_FORMAT &quot;&quot;</a>
<a name="ln49">  #endif</a>
<a name="ln50">  #define INT64_T_FORMAT &quot;I64&quot;</a>
<a name="ln51">  #define INTMAX_T_FORMAT &quot;I64&quot;</a>
<a name="ln52">#else</a>
<a name="ln53">  #define SIZE_T_FORMAT &quot;z&quot;</a>
<a name="ln54">  #define INT64_T_FORMAT &quot;ll&quot;</a>
<a name="ln55">  #define INTMAX_T_FORMAT &quot;j&quot;</a>
<a name="ln56">#endif</a>
<a name="ln57">#include &lt;stdint.h&gt;</a>
<a name="ln58">#endif</a>
<a name="ln59"> </a>
<a name="ln60">#include &lt;stdio.h&gt;	/* Include that here, to make sure __P gets defined */</a>
<a name="ln61">#include &lt;errno.h&gt;</a>
<a name="ln62">#include &lt;fcntl.h&gt;	/* For open and flags */</a>
<a name="ln63">#ifdef HAVE_INTTYPES_H</a>
<a name="ln64">#include &lt;inttypes.h&gt;</a>
<a name="ln65">#endif</a>
<a name="ln66">#include &lt;regex.h&gt;</a>
<a name="ln67">#include &lt;time.h&gt;</a>
<a name="ln68">#include &lt;sys/types.h&gt;</a>
<a name="ln69">#ifndef WIN32</a>
<a name="ln70">#include &lt;sys/param.h&gt;</a>
<a name="ln71">#endif</a>
<a name="ln72">/* Do this here and now, because struct stat gets re-defined on solaris */</a>
<a name="ln73">#include &lt;sys/stat.h&gt;</a>
<a name="ln74">#include &lt;stdarg.h&gt;</a>
<a name="ln75"> </a>
<a name="ln76">#define ENABLE_CONDITIONALS</a>
<a name="ln77"> </a>
<a name="ln78">#ifndef MAGIC</a>
<a name="ln79">#define MAGIC &quot;/etc/magic&quot;</a>
<a name="ln80">#endif</a>
<a name="ln81"> </a>
<a name="ln82">#if defined(__EMX__) || defined (WIN32)</a>
<a name="ln83">#define PATHSEP	';'</a>
<a name="ln84">#else</a>
<a name="ln85">#define PATHSEP	':'</a>
<a name="ln86">#endif</a>
<a name="ln87"> </a>
<a name="ln88">#define private static</a>
<a name="ln89"> </a>
<a name="ln90">#if HAVE_VISIBILITY &amp;&amp; !defined(WIN32)</a>
<a name="ln91">#define public  __attribute__ ((__visibility__(&quot;default&quot;)))</a>
<a name="ln92">#ifndef protected</a>
<a name="ln93">#define protected __attribute__ ((__visibility__(&quot;hidden&quot;)))</a>
<a name="ln94">#endif</a>
<a name="ln95">#else</a>
<a name="ln96">#define public</a>
<a name="ln97">#ifndef protected</a>
<a name="ln98">#define protected</a>
<a name="ln99">#endif</a>
<a name="ln100">#endif</a>
<a name="ln101"> </a>
<a name="ln102">#ifndef __arraycount</a>
<a name="ln103">#define __arraycount(a) (sizeof(a) / sizeof(a[0]))</a>
<a name="ln104">#endif</a>
<a name="ln105"> </a>
<a name="ln106">#ifndef __GNUC_PREREQ__</a>
<a name="ln107">#ifdef __GNUC__</a>
<a name="ln108">#define	__GNUC_PREREQ__(x, y)						\</a>
<a name="ln109">	((__GNUC__ == (x) &amp;&amp; __GNUC_MINOR__ &gt;= (y)) ||			\</a>
<a name="ln110">	 (__GNUC__ &gt; (x)))</a>
<a name="ln111">#else</a>
<a name="ln112">#define	__GNUC_PREREQ__(x, y)	0</a>
<a name="ln113">#endif</a>
<a name="ln114">#endif</a>
<a name="ln115"> </a>
<a name="ln116">#ifndef __GNUC__</a>
<a name="ln117">#ifndef __attribute__</a>
<a name="ln118">#define __attribute__(a)</a>
<a name="ln119">#endif</a>
<a name="ln120">#endif</a>
<a name="ln121"> </a>
<a name="ln122">#ifndef MIN</a>
<a name="ln123">#define	MIN(a,b)	(((a) &lt; (b)) ? (a) : (b))</a>
<a name="ln124">#endif</a>
<a name="ln125"> </a>
<a name="ln126">#ifndef MAX</a>
<a name="ln127">#define	MAX(a,b)	(((a) &gt; (b)) ? (a) : (b))</a>
<a name="ln128">#endif</a>
<a name="ln129"> </a>
<a name="ln130">#ifndef FILE_BYTES_MAX</a>
<a name="ln131"># define FILE_BYTES_MAX (1024 * 1024)	/* how much of the file to look at */</a>
<a name="ln132">#endif</a>
<a name="ln133">#define MAXMAGIS 8192		/* max entries in any one magic file</a>
<a name="ln134">				   or directory */</a>
<a name="ln135">#define MAXDESC	64		/* max len of text description/MIME type */</a>
<a name="ln136">#define MAXMIME	80		/* max len of text MIME type */</a>
<a name="ln137">#define MAXstring 96		/* max len of &quot;string&quot; types */</a>
<a name="ln138"> </a>
<a name="ln139">#define MAGICNO		0xF11E041C</a>
<a name="ln140">#define VERSIONNO	14</a>
<a name="ln141">#define FILE_MAGICSIZE	344</a>
<a name="ln142"> </a>
<a name="ln143">#define	FILE_LOAD	0</a>
<a name="ln144">#define FILE_CHECK	1</a>
<a name="ln145">#define FILE_COMPILE	2</a>
<a name="ln146">#define FILE_LIST	3</a>
<a name="ln147"> </a>
<a name="ln148">union VALUETYPE {</a>
<a name="ln149">	uint8_t b;</a>
<a name="ln150">	uint16_t h;</a>
<a name="ln151">	uint32_t l;</a>
<a name="ln152">	uint64_t q;</a>
<a name="ln153">	uint8_t hs[2];	/* 2 bytes of a fixed-endian &quot;short&quot; */</a>
<a name="ln154">	uint8_t hl[4];	/* 4 bytes of a fixed-endian &quot;long&quot; */</a>
<a name="ln155">	uint8_t hq[8];	/* 8 bytes of a fixed-endian &quot;quad&quot; */</a>
<a name="ln156">	char s[MAXstring];	/* the search string or regex pattern */</a>
<a name="ln157">	unsigned char us[MAXstring];</a>
<a name="ln158">	float f;</a>
<a name="ln159">	double d;</a>
<a name="ln160">};</a>
<a name="ln161"> </a>
<a name="ln162">struct magic {</a>
<a name="ln163">	/* Word 1 */</a>
<a name="ln164">	uint16_t cont_level;	/* level of &quot;&gt;&quot; */</a>
<a name="ln165">	uint8_t flag;</a>
<a name="ln166">#define INDIR		0x01	/* if '(...)' appears */</a>
<a name="ln167">#define OFFADD		0x02	/* if '&gt;&amp;' or '&gt;...(&amp;' appears */</a>
<a name="ln168">#define INDIROFFADD	0x04	/* if '&gt;&amp;(' appears */</a>
<a name="ln169">#define UNSIGNED	0x08	/* comparison is unsigned */</a>
<a name="ln170">#define NOSPACE		0x10	/* suppress space character before output */</a>
<a name="ln171">#define BINTEST		0x20	/* test is for a binary type (set only</a>
<a name="ln172">				   for top-level tests) */</a>
<a name="ln173">#define TEXTTEST	0x40	/* for passing to file_softmagic */</a>
<a name="ln174"> </a>
<a name="ln175">	uint8_t factor;</a>
<a name="ln176"> </a>
<a name="ln177">	/* Word 2 */</a>
<a name="ln178">	uint8_t reln;		/* relation (0=eq, '&gt;'=gt, etc) */</a>
<a name="ln179">	uint8_t vallen;		/* length of string value, if any */</a>
<a name="ln180">	uint8_t type;		/* comparison type (FILE_*) */</a>
<a name="ln181">	uint8_t in_type;	/* type of indirection */</a>
<a name="ln182">#define 			FILE_INVALID	0</a>
<a name="ln183">#define 			FILE_BYTE	1</a>
<a name="ln184">#define				FILE_SHORT	2</a>
<a name="ln185">#define				FILE_DEFAULT	3</a>
<a name="ln186">#define				FILE_LONG	4</a>
<a name="ln187">#define				FILE_STRING	5</a>
<a name="ln188">#define				FILE_DATE	6</a>
<a name="ln189">#define				FILE_BESHORT	7</a>
<a name="ln190">#define				FILE_BELONG	8</a>
<a name="ln191">#define				FILE_BEDATE	9</a>
<a name="ln192">#define				FILE_LESHORT	10</a>
<a name="ln193">#define				FILE_LELONG	11</a>
<a name="ln194">#define				FILE_LEDATE	12</a>
<a name="ln195">#define				FILE_PSTRING	13</a>
<a name="ln196">#define				FILE_LDATE	14</a>
<a name="ln197">#define				FILE_BELDATE	15</a>
<a name="ln198">#define				FILE_LELDATE	16</a>
<a name="ln199">#define				FILE_REGEX	17</a>
<a name="ln200">#define				FILE_BESTRING16	18</a>
<a name="ln201">#define				FILE_LESTRING16	19</a>
<a name="ln202">#define				FILE_SEARCH	20</a>
<a name="ln203">#define				FILE_MEDATE	21</a>
<a name="ln204">#define				FILE_MELDATE	22</a>
<a name="ln205">#define				FILE_MELONG	23</a>
<a name="ln206">#define				FILE_QUAD	24</a>
<a name="ln207">#define				FILE_LEQUAD	25</a>
<a name="ln208">#define				FILE_BEQUAD	26</a>
<a name="ln209">#define				FILE_QDATE	27</a>
<a name="ln210">#define				FILE_LEQDATE	28</a>
<a name="ln211">#define				FILE_BEQDATE	29</a>
<a name="ln212">#define				FILE_QLDATE	30</a>
<a name="ln213">#define				FILE_LEQLDATE	31</a>
<a name="ln214">#define				FILE_BEQLDATE	32</a>
<a name="ln215">#define				FILE_FLOAT	33</a>
<a name="ln216">#define				FILE_BEFLOAT	34</a>
<a name="ln217">#define				FILE_LEFLOAT	35</a>
<a name="ln218">#define				FILE_DOUBLE	36</a>
<a name="ln219">#define				FILE_BEDOUBLE	37</a>
<a name="ln220">#define				FILE_LEDOUBLE	38</a>
<a name="ln221">#define				FILE_BEID3	39</a>
<a name="ln222">#define				FILE_LEID3	40</a>
<a name="ln223">#define				FILE_INDIRECT	41</a>
<a name="ln224">#define				FILE_QWDATE	42</a>
<a name="ln225">#define				FILE_LEQWDATE	43</a>
<a name="ln226">#define				FILE_BEQWDATE	44</a>
<a name="ln227">#define				FILE_NAME	45</a>
<a name="ln228">#define				FILE_USE	46</a>
<a name="ln229">#define				FILE_CLEAR	47</a>
<a name="ln230">#define				FILE_DER	48</a>
<a name="ln231">#define				FILE_NAMES_SIZE	49 /* size of array to contain all names */</a>
<a name="ln232"> </a>
<a name="ln233">#define IS_STRING(t) \</a>
<a name="ln234">	((t) == FILE_STRING || \</a>
<a name="ln235">	 (t) == FILE_PSTRING || \</a>
<a name="ln236">	 (t) == FILE_BESTRING16 || \</a>
<a name="ln237">	 (t) == FILE_LESTRING16 || \</a>
<a name="ln238">	 (t) == FILE_REGEX || \</a>
<a name="ln239">	 (t) == FILE_SEARCH || \</a>
<a name="ln240">	 (t) == FILE_INDIRECT || \</a>
<a name="ln241">	 (t) == FILE_NAME || \</a>
<a name="ln242">	 (t) == FILE_USE)</a>
<a name="ln243"> </a>
<a name="ln244">#define FILE_FMT_NONE 0</a>
<a name="ln245">#define FILE_FMT_NUM  1 /* &quot;cduxXi&quot; */</a>
<a name="ln246">#define FILE_FMT_STR  2 /* &quot;s&quot; */</a>
<a name="ln247">#define FILE_FMT_QUAD 3 /* &quot;ll&quot; */</a>
<a name="ln248">#define FILE_FMT_FLOAT 4 /* &quot;eEfFgG&quot; */</a>
<a name="ln249">#define FILE_FMT_DOUBLE 5 /* &quot;eEfFgG&quot; */</a>
<a name="ln250"> </a>
<a name="ln251">	/* Word 3 */</a>
<a name="ln252">	uint8_t in_op;		/* operator for indirection */</a>
<a name="ln253">	uint8_t mask_op;	/* operator for mask */</a>
<a name="ln254">#ifdef ENABLE_CONDITIONALS</a>
<a name="ln255">	uint8_t cond;		/* conditional type */</a>
<a name="ln256">#else</a>
<a name="ln257">	uint8_t dummy;</a>
<a name="ln258">#endif</a>
<a name="ln259">	uint8_t factor_op;</a>
<a name="ln260">#define		FILE_FACTOR_OP_PLUS	'+'</a>
<a name="ln261">#define		FILE_FACTOR_OP_MINUS	'-'</a>
<a name="ln262">#define		FILE_FACTOR_OP_TIMES	'*'</a>
<a name="ln263">#define		FILE_FACTOR_OP_DIV	'/'</a>
<a name="ln264">#define		FILE_FACTOR_OP_NONE	'\0'</a>
<a name="ln265"> </a>
<a name="ln266">#define				FILE_OPS	&quot;&amp;|^+-*/%&quot;</a>
<a name="ln267">#define				FILE_OPAND	0</a>
<a name="ln268">#define				FILE_OPOR	1</a>
<a name="ln269">#define				FILE_OPXOR	2</a>
<a name="ln270">#define				FILE_OPADD	3</a>
<a name="ln271">#define				FILE_OPMINUS	4</a>
<a name="ln272">#define				FILE_OPMULTIPLY	5</a>
<a name="ln273">#define				FILE_OPDIVIDE	6</a>
<a name="ln274">#define				FILE_OPMODULO	7</a>
<a name="ln275">#define				FILE_OPS_MASK	0x07 /* mask for above ops */</a>
<a name="ln276">#define				FILE_UNUSED_1	0x08</a>
<a name="ln277">#define				FILE_UNUSED_2	0x10</a>
<a name="ln278">#define				FILE_OPSIGNED	0x20</a>
<a name="ln279">#define				FILE_OPINVERSE	0x40</a>
<a name="ln280">#define				FILE_OPINDIRECT	0x80</a>
<a name="ln281"> </a>
<a name="ln282">#ifdef ENABLE_CONDITIONALS</a>
<a name="ln283">#define				COND_NONE	0</a>
<a name="ln284">#define				COND_IF		1</a>
<a name="ln285">#define				COND_ELIF	2</a>
<a name="ln286">#define				COND_ELSE	3</a>
<a name="ln287">#endif /* ENABLE_CONDITIONALS */</a>
<a name="ln288"> </a>
<a name="ln289">	/* Word 4 */</a>
<a name="ln290">	uint32_t offset;	/* offset to magic number */</a>
<a name="ln291">	/* Word 5 */</a>
<a name="ln292">	int32_t in_offset;	/* offset from indirection */</a>
<a name="ln293">	/* Word 6 */</a>
<a name="ln294">	uint32_t lineno;	/* line number in magic file */</a>
<a name="ln295">	/* Word 7,8 */</a>
<a name="ln296">	union {</a>
<a name="ln297">		uint64_t _mask;	/* for use with numeric and date types */</a>
<a name="ln298">		struct {</a>
<a name="ln299">			uint32_t _count;	/* repeat/line count */</a>
<a name="ln300">			uint32_t _flags;	/* modifier flags */</a>
<a name="ln301">		} _s;		/* for use with string types */</a>
<a name="ln302">	} _u;</a>
<a name="ln303">#define num_mask _u._mask</a>
<a name="ln304">#define str_range _u._s._count</a>
<a name="ln305">#define str_flags _u._s._flags</a>
<a name="ln306">	/* Words 9-24 */</a>
<a name="ln307">	union VALUETYPE value;	/* either number or string */</a>
<a name="ln308">	/* Words 25-40 */</a>
<a name="ln309">	char desc[MAXDESC];	/* description */</a>
<a name="ln310">	/* Words 41-60 */</a>
<a name="ln311">	char mimetype[MAXMIME]; /* MIME type */</a>
<a name="ln312">	/* Words 61-62 */</a>
<a name="ln313">	char apple[8];		/* APPLE CREATOR/TYPE */</a>
<a name="ln314">	/* Words 63-78 */</a>
<a name="ln315">	char ext[64];		/* Popular extensions */</a>
<a name="ln316">};</a>
<a name="ln317"> </a>
<a name="ln318">#define BIT(A)   (1 &lt;&lt; (A))</a>
<a name="ln319">#define STRING_COMPACT_WHITESPACE		BIT(0)</a>
<a name="ln320">#define STRING_COMPACT_OPTIONAL_WHITESPACE	BIT(1)</a>
<a name="ln321">#define STRING_IGNORE_LOWERCASE			BIT(2)</a>
<a name="ln322">#define STRING_IGNORE_UPPERCASE			BIT(3)</a>
<a name="ln323">#define REGEX_OFFSET_START			BIT(4)</a>
<a name="ln324">#define STRING_TEXTTEST				BIT(5)</a>
<a name="ln325">#define STRING_BINTEST				BIT(6)</a>
<a name="ln326">#define PSTRING_1_BE				BIT(7)</a>
<a name="ln327">#define PSTRING_1_LE				BIT(7)</a>
<a name="ln328">#define PSTRING_2_BE				BIT(8)</a>
<a name="ln329">#define PSTRING_2_LE				BIT(9)</a>
<a name="ln330">#define PSTRING_4_BE				BIT(10)</a>
<a name="ln331">#define PSTRING_4_LE				BIT(11)</a>
<a name="ln332">#define REGEX_LINE_COUNT			BIT(11)</a>
<a name="ln333">#define PSTRING_LEN	\</a>
<a name="ln334">    (PSTRING_1_BE|PSTRING_2_LE|PSTRING_2_BE|PSTRING_4_LE|PSTRING_4_BE)</a>
<a name="ln335">#define PSTRING_LENGTH_INCLUDES_ITSELF		BIT(12)</a>
<a name="ln336">#define	STRING_TRIM				BIT(13)</a>
<a name="ln337">#define CHAR_COMPACT_WHITESPACE			'W'</a>
<a name="ln338">#define CHAR_COMPACT_OPTIONAL_WHITESPACE	'w'</a>
<a name="ln339">#define CHAR_IGNORE_LOWERCASE			'c'</a>
<a name="ln340">#define CHAR_IGNORE_UPPERCASE			'C'</a>
<a name="ln341">#define CHAR_REGEX_OFFSET_START			's'</a>
<a name="ln342">#define CHAR_TEXTTEST				't'</a>
<a name="ln343">#define	CHAR_TRIM				'T'</a>
<a name="ln344">#define CHAR_BINTEST				'b'</a>
<a name="ln345">#define CHAR_PSTRING_1_BE			'B'</a>
<a name="ln346">#define CHAR_PSTRING_1_LE			'B'</a>
<a name="ln347">#define CHAR_PSTRING_2_BE			'H'</a>
<a name="ln348">#define CHAR_PSTRING_2_LE			'h'</a>
<a name="ln349">#define CHAR_PSTRING_4_BE			'L'</a>
<a name="ln350">#define CHAR_PSTRING_4_LE			'l'</a>
<a name="ln351">#define CHAR_PSTRING_LENGTH_INCLUDES_ITSELF     'J'</a>
<a name="ln352">#define STRING_IGNORE_CASE		(STRING_IGNORE_LOWERCASE|STRING_IGNORE_UPPERCASE)</a>
<a name="ln353">#define STRING_DEFAULT_RANGE		100</a>
<a name="ln354"> </a>
<a name="ln355">#define	INDIRECT_RELATIVE			BIT(0)</a>
<a name="ln356">#define	CHAR_INDIRECT_RELATIVE			'r'</a>
<a name="ln357"> </a>
<a name="ln358">/* list of magic entries */</a>
<a name="ln359">struct mlist {</a>
<a name="ln360">	struct magic *magic;		/* array of magic entries */</a>
<a name="ln361">	uint32_t nmagic;		/* number of entries in array */</a>
<a name="ln362">	void *map;			/* internal resources used by entry */</a>
<a name="ln363">	struct mlist *next, *prev;</a>
<a name="ln364">};</a>
<a name="ln365"> </a>
<a name="ln366">#ifdef __cplusplus</a>
<a name="ln367">#define CAST(T, b)	static_cast&lt;T&gt;(b)</a>
<a name="ln368">#define RCAST(T, b)	reinterpret_cast&lt;T&gt;(b)</a>
<a name="ln369">#define CCAST(T, b)	const_cast&lt;T&gt;(b)</a>
<a name="ln370">#else</a>
<a name="ln371">#define CAST(T, b)	((T)(b))</a>
<a name="ln372">#define RCAST(T, b)	((T)(b))</a>
<a name="ln373">#define CCAST(T, b)	((T)(uintptr_t)(b))</a>
<a name="ln374">#endif</a>
<a name="ln375"> </a>
<a name="ln376">struct level_info {</a>
<a name="ln377">	int32_t off;</a>
<a name="ln378">	int got_match;</a>
<a name="ln379">#ifdef ENABLE_CONDITIONALS</a>
<a name="ln380">	int last_match;</a>
<a name="ln381">	int last_cond;	/* used for error checking by parse() */</a>
<a name="ln382">#endif</a>
<a name="ln383">};</a>
<a name="ln384"> </a>
<a name="ln385">#define MAGIC_SETS	2</a>
<a name="ln386"> </a>
<a name="ln387">struct magic_set {</a>
<a name="ln388">	struct mlist *mlist[MAGIC_SETS];	/* list of regular entries */</a>
<a name="ln389">	struct cont {</a>
<a name="ln390">		size_t len;</a>
<a name="ln391">		struct level_info *li;</a>
<a name="ln392">	} c;</a>
<a name="ln393">	struct out {</a>
<a name="ln394">		char *buf;		/* Accumulation buffer */</a>
<a name="ln395">		char *pbuf;		/* Printable buffer */</a>
<a name="ln396">	} o;</a>
<a name="ln397">	uint32_t offset;</a>
<a name="ln398">	int error;</a>
<a name="ln399">	int flags;			/* Control magic tests. */</a>
<a name="ln400">	int event_flags;		/* Note things that happened. */</a>
<a name="ln401">#define 		EVENT_HAD_ERR		0x01</a>
<a name="ln402">	const char *file;</a>
<a name="ln403">	size_t line;			/* current magic line number */</a>
<a name="ln404"> </a>
<a name="ln405">	/* data for searches */</a>
<a name="ln406">	struct {</a>
<a name="ln407">		const char *s;		/* start of search in original source */</a>
<a name="ln408">		size_t s_len;		/* length of search region */</a>
<a name="ln409">		size_t offset;		/* starting offset in source: XXX - should this be off_t? */</a>
<a name="ln410">		size_t rm_len;		/* match length */</a>
<a name="ln411">	} search;</a>
<a name="ln412"> </a>
<a name="ln413">	/* FIXME: Make the string dynamically allocated so that e.g.</a>
<a name="ln414">	   strings matched in files can be longer than MAXstring */</a>
<a name="ln415">	union VALUETYPE ms_value;	/* either number or string */</a>
<a name="ln416">	uint16_t indir_max;</a>
<a name="ln417">	uint16_t name_max;</a>
<a name="ln418">	uint16_t elf_shnum_max;</a>
<a name="ln419">	uint16_t elf_phnum_max;</a>
<a name="ln420">	uint16_t elf_notes_max;</a>
<a name="ln421">	uint16_t regex_max;</a>
<a name="ln422">	size_t bytes_max;		/* number of bytes to read from file */</a>
<a name="ln423">#define	FILE_INDIR_MAX			50</a>
<a name="ln424">#define	FILE_NAME_MAX			30</a>
<a name="ln425">#define	FILE_ELF_SHNUM_MAX		32768</a>
<a name="ln426">#define	FILE_ELF_PHNUM_MAX		2048</a>
<a name="ln427">#define	FILE_ELF_NOTES_MAX		256</a>
<a name="ln428">#define	FILE_REGEX_MAX			8192</a>
<a name="ln429">};</a>
<a name="ln430"> </a>
<a name="ln431">/* Type for Unicode characters */</a>
<a name="ln432">typedef unsigned long unichar;</a>
<a name="ln433"> </a>
<a name="ln434">struct stat;</a>
<a name="ln435">#define FILE_T_LOCAL	1</a>
<a name="ln436">#define FILE_T_WINDOWS	2</a>
<a name="ln437">protected const char *file_fmttime(uint64_t, int, char *);</a>
<a name="ln438">protected struct magic_set *file_ms_alloc(int);</a>
<a name="ln439">protected void file_ms_free(struct magic_set *);</a>
<a name="ln440">protected int file_buffer(struct magic_set *, int, const char *, const void *,</a>
<a name="ln441">    size_t);</a>
<a name="ln442">protected int file_fsmagic(struct magic_set *, const char *, struct stat *);</a>
<a name="ln443">protected int file_pipe2file(struct magic_set *, int, const void *, size_t);</a>
<a name="ln444">protected int file_vprintf(struct magic_set *, const char *, va_list)</a>
<a name="ln445">    __attribute__((__format__(__printf__, 2, 0)));</a>
<a name="ln446">protected size_t file_printedlen(const struct magic_set *);</a>
<a name="ln447">protected int file_replace(struct magic_set *, const char *, const char *);</a>
<a name="ln448">protected int file_printf(struct magic_set *, const char *, ...)</a>
<a name="ln449">    __attribute__((__format__(__printf__, 2, 3)));</a>
<a name="ln450">protected int file_reset(struct magic_set *);</a>
<a name="ln451">protected int file_tryelf(struct magic_set *, int, const unsigned char *,</a>
<a name="ln452">    size_t);</a>
<a name="ln453">protected int file_trycdf(struct magic_set *, int, const unsigned char *,</a>
<a name="ln454">    size_t);</a>
<a name="ln455">#if HAVE_FORK</a>
<a name="ln456">protected int file_zmagic(struct magic_set *, int, const char *,</a>
<a name="ln457">    const unsigned char *, size_t);</a>
<a name="ln458">#endif</a>
<a name="ln459">protected int file_ascmagic(struct magic_set *, const unsigned char *, size_t,</a>
<a name="ln460">    int);</a>
<a name="ln461">protected int file_ascmagic_with_encoding(struct magic_set *,</a>
<a name="ln462">    const unsigned char *, size_t, unichar *, size_t, const char *,</a>
<a name="ln463">    const char *, int);</a>
<a name="ln464">protected int file_encoding(struct magic_set *, const unsigned char *, size_t,</a>
<a name="ln465">    unichar **, size_t *, const char **, const char **, const char **);</a>
<a name="ln466">protected int file_is_tar(struct magic_set *, const unsigned char *, size_t);</a>
<a name="ln467">protected int file_softmagic(struct magic_set *, const unsigned char *, size_t,</a>
<a name="ln468">    uint16_t *, uint16_t *, int, int);</a>
<a name="ln469">protected int file_apprentice(struct magic_set *, const char *, int);</a>
<a name="ln470">protected int buffer_apprentice(struct magic_set *, struct magic **,</a>
<a name="ln471">    size_t *, size_t);</a>
<a name="ln472">protected int file_magicfind(struct magic_set *, const char *, struct mlist *);</a>
<a name="ln473">protected uint64_t file_signextend(struct magic_set *, struct magic *,</a>
<a name="ln474">    uint64_t);</a>
<a name="ln475">protected void file_badread(struct magic_set *);</a>
<a name="ln476">protected void file_badseek(struct magic_set *);</a>
<a name="ln477">protected void file_oomem(struct magic_set *, size_t);</a>
<a name="ln478">protected void file_error(struct magic_set *, int, const char *, ...)</a>
<a name="ln479">    __attribute__((__format__(__printf__, 3, 4)));</a>
<a name="ln480">protected void file_magerror(struct magic_set *, const char *, ...)</a>
<a name="ln481">    __attribute__((__format__(__printf__, 2, 3)));</a>
<a name="ln482">protected void file_magwarn(struct magic_set *, const char *, ...)</a>
<a name="ln483">    __attribute__((__format__(__printf__, 2, 3)));</a>
<a name="ln484">protected void file_mdump(struct magic *);</a>
<a name="ln485">protected void file_showstr(FILE *, const char *, size_t);</a>
<a name="ln486">protected size_t file_mbswidth(const char *);</a>
<a name="ln487">protected const char *file_getbuffer(struct magic_set *);</a>
<a name="ln488">protected ssize_t sread(int, void *, size_t, int);</a>
<a name="ln489">protected int file_check_mem(struct magic_set *, unsigned int);</a>
<a name="ln490">protected int file_looks_utf8(const unsigned char *, size_t, unichar *,</a>
<a name="ln491">    size_t *);</a>
<a name="ln492">protected size_t file_pstring_length_size(const struct magic *);</a>
<a name="ln493">protected size_t file_pstring_get_length(const struct magic *, const char *);</a>
<a name="ln494">protected char * file_printable(char *, size_t, const char *);</a>
<a name="ln495">#ifdef __EMX__</a>
<a name="ln496">protected int file_os2_apptype(struct magic_set *, const char *, const void *,</a>
<a name="ln497">    size_t);</a>
<a name="ln498">#endif /* __EMX__ */</a>
<a name="ln499"> </a>
<a name="ln500">#if defined(HAVE_LOCALE_H)</a>
<a name="ln501">#include &lt;locale.h&gt;</a>
<a name="ln502">#endif</a>
<a name="ln503">#if defined(HAVE_XLOCALE_H)</a>
<a name="ln504">#include &lt;xlocale.h&gt;</a>
<a name="ln505">#endif</a>
<a name="ln506"> </a>
<a name="ln507">typedef struct {</a>
<a name="ln508">	const char *pat;</a>
<a name="ln509">#if defined(HAVE_NEWLOCALE) &amp;&amp; defined(HAVE_USELOCALE) &amp;&amp; defined(HAVE_FREELOCALE)</a>
<a name="ln510">#define USE_C_LOCALE</a>
<a name="ln511">	locale_t old_lc_ctype;</a>
<a name="ln512">	locale_t c_lc_ctype;</a>
<a name="ln513">#else</a>
<a name="ln514">	char *old_lc_ctype;</a>
<a name="ln515">#endif</a>
<a name="ln516">	int rc;</a>
<a name="ln517">	regex_t rx;</a>
<a name="ln518">} file_regex_t;</a>
<a name="ln519"> </a>
<a name="ln520">protected int file_regcomp(file_regex_t *, const char *, int);</a>
<a name="ln521">protected int file_regexec(file_regex_t *, const char *, size_t, regmatch_t *,</a>
<a name="ln522">    int);</a>
<a name="ln523">protected void file_regfree(file_regex_t *);</a>
<a name="ln524">protected void file_regerror(file_regex_t *, int, struct magic_set *);</a>
<a name="ln525"> </a>
<a name="ln526">typedef struct {</a>
<a name="ln527">	char *buf;</a>
<a name="ln528">	uint32_t offset;</a>
<a name="ln529">} file_pushbuf_t;</a>
<a name="ln530"> </a>
<a name="ln531">protected file_pushbuf_t *file_push_buffer(struct magic_set *);</a>
<a name="ln532">protected char  *file_pop_buffer(struct magic_set *, file_pushbuf_t *);</a>
<a name="ln533"> </a>
<a name="ln534">#ifndef COMPILE_ONLY</a>
<a name="ln535">extern const char *file_names[];</a>
<a name="ln536">extern const size_t file_nnames;</a>
<a name="ln537">#endif</a>
<a name="ln538"> </a>
<a name="ln539">#ifndef HAVE_STRERROR</a>
<a name="ln540">extern int sys_nerr;</a>
<a name="ln541">extern char *sys_errlist[];</a>
<a name="ln542">#define strerror(e) \</a>
<a name="ln543">	(((e) &gt;= 0 &amp;&amp; (e) &lt; sys_nerr) ? sys_errlist[(e)] : &quot;Unknown error&quot;)</a>
<a name="ln544">#endif</a>
<a name="ln545"> </a>
<a name="ln546">#ifndef HAVE_STRTOUL</a>
<a name="ln547">#define strtoul(a, b, c)	strtol(a, b, c)</a>
<a name="ln548">#endif</a>
<a name="ln549"> </a>
<a name="ln550">#ifndef HAVE_PREAD</a>
<a name="ln551">ssize_t pread(int, void *, size_t, off_t);</a>
<a name="ln552">#endif</a>
<a name="ln553">#ifndef HAVE_VASPRINTF</a>
<a name="ln554">int vasprintf(char **, const char *, va_list);</a>
<a name="ln555">#endif</a>
<a name="ln556">#ifndef HAVE_ASPRINTF</a>
<a name="ln557">int asprintf(char **, const char *, ...);</a>
<a name="ln558">#endif</a>
<a name="ln559">#ifndef HAVE_DPRINTF</a>
<a name="ln560">int dprintf(int, const char *, ...);</a>
<a name="ln561">#endif</a>
<a name="ln562"> </a>
<a name="ln563">#ifndef HAVE_STRLCPY</a>
<a name="ln564">size_t strlcpy(char *, const char *, size_t);</a>
<a name="ln565">#endif</a>
<a name="ln566">#ifndef HAVE_STRLCAT</a>
<a name="ln567">size_t strlcat(char *, const char *, size_t);</a>
<a name="ln568">#endif</a>
<a name="ln569">#ifndef HAVE_STRCASESTR</a>
<a name="ln570">char *strcasestr(const char *, const char *);</a>
<a name="ln571">#endif</a>
<a name="ln572">#ifndef HAVE_GETLINE</a>
<a name="ln573">ssize_t getline(char **, size_t *, FILE *);</a>
<a name="ln574">ssize_t getdelim(char **, size_t *, int, FILE *);</a>
<a name="ln575">#endif</a>
<a name="ln576">#ifndef HAVE_CTIME_R</a>
<a name="ln577">char   *ctime_r(const time_t *, char *);</a>
<a name="ln578">#endif</a>
<a name="ln579">#ifndef HAVE_ASCTIME_R</a>
<a name="ln580">char   *asctime_r(const struct tm *, char *);</a>
<a name="ln581">#endif</a>
<a name="ln582">#ifndef HAVE_GMTIME_R</a>
<a name="ln583">struct tm *gmtime_r(const time_t *, struct tm *);</a>
<a name="ln584">#endif</a>
<a name="ln585">#ifndef HAVE_LOCALTIME_R</a>
<a name="ln586">struct tm *localtime_r(const time_t *, struct tm *);</a>
<a name="ln587">#endif</a>
<a name="ln588">#ifndef HAVE_FMTCHECK</a>
<a name="ln589">const char *fmtcheck(const char *, const char *) </a>
<a name="ln590">     __attribute__((__format_arg__(2)));</a>
<a name="ln591">#endif</a>
<a name="ln592"> </a>
<a name="ln593">#if defined(HAVE_MMAP) &amp;&amp; defined(HAVE_SYS_MMAN_H) &amp;&amp; !defined(QUICK)</a>
<a name="ln594">#define QUICK</a>
<a name="ln595">#endif</a>
<a name="ln596"> </a>
<a name="ln597">#ifndef O_BINARY</a>
<a name="ln598">#define O_BINARY	0</a>
<a name="ln599">#endif</a>
<a name="ln600"> </a>
<a name="ln601">#ifndef __cplusplus</a>
<a name="ln602">#if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 3)</a>
<a name="ln603">#define FILE_RCSID(id) \</a>
<a name="ln604">static const char rcsid[] __attribute__((__used__)) = id;</a>
<a name="ln605">#else</a>
<a name="ln606">#define FILE_RCSID(id) \</a>
<a name="ln607">static const char *rcsid(const char *p) { \</a>
<a name="ln608">	return rcsid(p = id); \</a>
<a name="ln609">}</a>
<a name="ln610">#endif</a>
<a name="ln611">#else</a>
<a name="ln612">#define FILE_RCSID(id)</a>
<a name="ln613">#endif</a>
<a name="ln614">#ifndef __RCSID</a>
<a name="ln615">#define __RCSID(a)</a>
<a name="ln616">#endif</a>
<a name="ln617"> </a>
<a name="ln618">#endif /* __file_h__ */</a>
</code></pre>
<div class="balloon" rel="448"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1071/" target="_blank">V1071</a> Consider inspecting the 'file_printf' function. The return value is not always used. Total calls: 61, discarded results: 1.</p></div>
<div class="balloon" rel="542"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1059/" target="_blank">V1059</a> The 'strerror' macro name overrides a reserved name from C standard. This may lead to undefined behavior.</p></div>
<div class="balloon" rel="547"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1059/" target="_blank">V1059</a> The 'strtoul' macro name overrides a reserved name from C standard. This may lead to undefined behavior.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>