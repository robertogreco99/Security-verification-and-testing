<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ascmagic.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com</a>
<a name="ln3">/*</a>
<a name="ln4"> * Copyright (c) Ian F. Darwin 1986-1995.</a>
<a name="ln5"> * Software written by Ian F. Darwin and others;</a>
<a name="ln6"> * maintained 1995-present by Christos Zoulas and others.</a>
<a name="ln7"> *</a>
<a name="ln8"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln9"> * modification, are permitted provided that the following conditions</a>
<a name="ln10"> * are met:</a>
<a name="ln11"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln12"> *    notice immediately at the beginning of the file, without modification,</a>
<a name="ln13"> *    this list of conditions, and the following disclaimer.</a>
<a name="ln14"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln15"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln16"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln17"> *</a>
<a name="ln18"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln19"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln20"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln21"> * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR</a>
<a name="ln22"> * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln23"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln24"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln25"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln26"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln27"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln28"> * SUCH DAMAGE.</a>
<a name="ln29"> */</a>
<a name="ln30">/*</a>
<a name="ln31"> * ASCII magic -- try to detect text encoding.</a>
<a name="ln32"> *</a>
<a name="ln33"> * Extensively modified by Eric Fischer &lt;enf@pobox.com&gt; in July, 2000,</a>
<a name="ln34"> * to handle character codes other than ASCII on a unified basis.</a>
<a name="ln35"> */</a>
<a name="ln36"> </a>
<a name="ln37">#include &quot;file.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#ifndef	lint</a>
<a name="ln40">FILE_RCSID(&quot;@(#)$File: ascmagic.c,v 1.96 2016/06/16 11:37:55 christos Exp $&quot;)</a>
<a name="ln41">#endif	/* lint */</a>
<a name="ln42"> </a>
<a name="ln43">#include &quot;magic.h&quot;</a>
<a name="ln44">#include &lt;string.h&gt;</a>
<a name="ln45">#include &lt;memory.h&gt;</a>
<a name="ln46">#include &lt;ctype.h&gt;</a>
<a name="ln47">#include &lt;stdlib.h&gt;</a>
<a name="ln48">#ifdef HAVE_UNISTD_H</a>
<a name="ln49">#include &lt;unistd.h&gt;</a>
<a name="ln50">#endif</a>
<a name="ln51"> </a>
<a name="ln52">#define MAXLINELEN 300	/* longest sane line length */</a>
<a name="ln53">#define ISSPC(x) ((x) == ' ' || (x) == '\t' || (x) == '\r' || (x) == '\n' \</a>
<a name="ln54">		  || (x) == 0x85 || (x) == '\f')</a>
<a name="ln55"> </a>
<a name="ln56">private unsigned char *encode_utf8(unsigned char *, size_t, unichar *, size_t);</a>
<a name="ln57">private size_t trim_nuls(const unsigned char *, size_t);</a>
<a name="ln58"> </a>
<a name="ln59">/*</a>
<a name="ln60"> * Undo the NUL-termination kindly provided by process()</a>
<a name="ln61"> * but leave at least one byte to look at</a>
<a name="ln62"> */</a>
<a name="ln63">private size_t</a>
<a name="ln64">trim_nuls(const unsigned char *buf, size_t nbytes)</a>
<a name="ln65">{</a>
<a name="ln66">	while (nbytes &gt; 1 &amp;&amp; buf[nbytes - 1] == '\0')</a>
<a name="ln67">		nbytes--;</a>
<a name="ln68"> </a>
<a name="ln69">	return nbytes;</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">protected int</a>
<a name="ln73">file_ascmagic(struct magic_set *ms, const unsigned char *buf, size_t nbytes,</a>
<a name="ln74">	int text)</a>
<a name="ln75">{</a>
<a name="ln76">	unichar *ubuf = NULL;</a>
<a name="ln77">	size_t ulen = 0;</a>
<a name="ln78">	int rv = 1;</a>
<a name="ln79"> </a>
<a name="ln80">	const char *code = NULL;</a>
<a name="ln81">	const char *code_mime = NULL;</a>
<a name="ln82">	const char *type = NULL;</a>
<a name="ln83"> </a>
<a name="ln84">	nbytes = trim_nuls(buf, nbytes);</a>
<a name="ln85"> </a>
<a name="ln86">	/* If file doesn't look like any sort of text, give up. */</a>
<a name="ln87">	if (file_encoding(ms, buf, nbytes, &amp;ubuf, &amp;ulen, &amp;code, &amp;code_mime,</a>
<a name="ln88">	    &amp;type) == 0)</a>
<a name="ln89">		rv = 0;</a>
<a name="ln90">        else</a>
<a name="ln91">		rv = file_ascmagic_with_encoding(ms, buf, nbytes, ubuf, ulen, code,</a>
<a name="ln92">						 type, text);</a>
<a name="ln93"> </a>
<a name="ln94">	free(ubuf);</a>
<a name="ln95"> </a>
<a name="ln96">	return rv;</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">protected int</a>
<a name="ln100">file_ascmagic_with_encoding(struct magic_set *ms, const unsigned char *buf,</a>
<a name="ln101">    size_t nbytes, unichar *ubuf, size_t ulen, const char *code,</a>
<a name="ln102">    const char *type, int text)</a>
<a name="ln103">{</a>
<a name="ln104">	unsigned char *utf8_buf = NULL, *utf8_end;</a>
<a name="ln105">	size_t mlen, i;</a>
<a name="ln106">	int rv = -1;</a>
<a name="ln107">	int mime = ms-&gt;flags &amp; MAGIC_MIME;</a>
<a name="ln108"> </a>
<a name="ln109">	const char *subtype = NULL;</a>
<a name="ln110">	const char *subtype_mime = NULL;</a>
<a name="ln111"> </a>
<a name="ln112">	int has_escapes = 0;</a>
<a name="ln113">	int has_backspace = 0;</a>
<a name="ln114">	int seen_cr = 0;</a>
<a name="ln115"> </a>
<a name="ln116">	int n_crlf = 0;</a>
<a name="ln117">	int n_lf = 0;</a>
<a name="ln118">	int n_cr = 0;</a>
<a name="ln119">	int n_nel = 0;</a>
<a name="ln120">	int executable = 0;</a>
<a name="ln121"> </a>
<a name="ln122">	size_t last_line_end = (size_t)-1;</a>
<a name="ln123">	int has_long_lines = 0;</a>
<a name="ln124"> </a>
<a name="ln125">	nbytes = trim_nuls(buf, nbytes);</a>
<a name="ln126"> </a>
<a name="ln127">	/* If we have fewer than 2 bytes, give up. */</a>
<a name="ln128">	if (nbytes &lt;= 1) {</a>
<a name="ln129">		rv = 0;</a>
<a name="ln130">		goto done;</a>
<a name="ln131">	}</a>
<a name="ln132"> </a>
<a name="ln133">	if (ulen &gt; 0 &amp;&amp; (ms-&gt;flags &amp; MAGIC_NO_CHECK_SOFT) == 0) {</a>
<a name="ln134">		/* Convert ubuf to UTF-8 and try text soft magic */</a>
<a name="ln135">		/* malloc size is a conservative overestimate; could be</a>
<a name="ln136">		   improved, or at least realloced after conversion. */</a>
<a name="ln137">		mlen = ulen * 6;</a>
<a name="ln138">		if ((utf8_buf = CAST(unsigned char *, malloc(mlen))) == NULL) {</a>
<a name="ln139">			file_oomem(ms, mlen);</a>
<a name="ln140">			goto done;</a>
<a name="ln141">		}</a>
<a name="ln142">		if ((utf8_end = encode_utf8(utf8_buf, mlen, ubuf, ulen))</a>
<a name="ln143">		    == NULL)</a>
<a name="ln144">			goto done;</a>
<a name="ln145">		if ((rv = file_softmagic(ms, utf8_buf,</a>
<a name="ln146">		    (size_t)(utf8_end - utf8_buf), NULL, NULL,</a>
<a name="ln147">		    TEXTTEST, text)) == 0)</a>
<a name="ln148">			rv = -1;</a>
<a name="ln149">		if ((ms-&gt;flags &amp; (MAGIC_APPLE|MAGIC_EXTENSION))) {</a>
<a name="ln150">			rv = rv == -1 ? 0 : 1;</a>
<a name="ln151">			goto done;</a>
<a name="ln152">		}</a>
<a name="ln153">	}</a>
<a name="ln154">	if ((ms-&gt;flags &amp; (MAGIC_APPLE|MAGIC_EXTENSION)))</a>
<a name="ln155">		return 0;</a>
<a name="ln156"> </a>
<a name="ln157">	/* Now try to discover other details about the file. */</a>
<a name="ln158">	for (i = 0; i &lt; ulen; i++) {</a>
<a name="ln159">		if (ubuf[i] == '\n') {</a>
<a name="ln160">			if (seen_cr)</a>
<a name="ln161">				n_crlf++;</a>
<a name="ln162">			else</a>
<a name="ln163">				n_lf++;</a>
<a name="ln164">			last_line_end = i;</a>
<a name="ln165">		} else if (seen_cr)</a>
<a name="ln166">			n_cr++;</a>
<a name="ln167"> </a>
<a name="ln168">		seen_cr = (ubuf[i] == '\r');</a>
<a name="ln169">		if (seen_cr)</a>
<a name="ln170">			last_line_end = i;</a>
<a name="ln171"> </a>
<a name="ln172">		if (ubuf[i] == 0x85) { /* X3.64/ECMA-43 &quot;next line&quot; character */</a>
<a name="ln173">			n_nel++;</a>
<a name="ln174">			last_line_end = i;</a>
<a name="ln175">		}</a>
<a name="ln176"> </a>
<a name="ln177">		/* If this line is _longer_ than MAXLINELEN, remember it. */</a>
<a name="ln178">		if (i &gt; last_line_end + MAXLINELEN)</a>
<a name="ln179">			has_long_lines = 1;</a>
<a name="ln180"> </a>
<a name="ln181">		if (ubuf[i] == '\033')</a>
<a name="ln182">			has_escapes = 1;</a>
<a name="ln183">		if (ubuf[i] == '\b')</a>
<a name="ln184">			has_backspace = 1;</a>
<a name="ln185">	}</a>
<a name="ln186"> </a>
<a name="ln187">	/* Beware, if the data has been truncated, the final CR could have</a>
<a name="ln188">	   been followed by a LF.  If we have ms-&gt;bytes_max bytes, it indicates</a>
<a name="ln189">	   that the data might have been truncated, probably even before</a>
<a name="ln190">	   this function was called. */</a>
<a name="ln191">	if (seen_cr &amp;&amp; nbytes &lt; ms-&gt;bytes_max)</a>
<a name="ln192">		n_cr++;</a>
<a name="ln193"> </a>
<a name="ln194">	if (strcmp(type, &quot;binary&quot;) == 0) {</a>
<a name="ln195">		rv = 0;</a>
<a name="ln196">		goto done;</a>
<a name="ln197">	}</a>
<a name="ln198">	if (mime) {</a>
<a name="ln199">		if (!file_printedlen(ms) &amp;&amp; (mime &amp; MAGIC_MIME_TYPE) != 0) {</a>
<a name="ln200">			if (subtype_mime) {</a>
<a name="ln201">				if (file_printf(ms, &quot;%s&quot;, subtype_mime) == -1)</a>
<a name="ln202">					goto done;</a>
<a name="ln203">			} else {</a>
<a name="ln204">				if (file_printf(ms, &quot;text/plain&quot;) == -1)</a>
<a name="ln205">					goto done;</a>
<a name="ln206">			}</a>
<a name="ln207">		}</a>
<a name="ln208">	} else {</a>
<a name="ln209">		if (file_printedlen(ms)) {</a>
<a name="ln210">			switch (file_replace(ms, &quot; text$&quot;, &quot;, &quot;)) {</a>
<a name="ln211">			case 0:</a>
<a name="ln212">				switch (file_replace(ms, &quot; text executable$&quot;,</a>
<a name="ln213">				    &quot;, &quot;)) {</a>
<a name="ln214">				case 0:</a>
<a name="ln215">					if (file_printf(ms, &quot;, &quot;) == -1)</a>
<a name="ln216">						goto done;</a>
<a name="ln217">					break;</a>
<a name="ln218">				case -1:</a>
<a name="ln219">					goto done;</a>
<a name="ln220">				default:</a>
<a name="ln221">					executable = 1;</a>
<a name="ln222">					break;</a>
<a name="ln223">				}</a>
<a name="ln224">				break;</a>
<a name="ln225">			case -1:</a>
<a name="ln226">				goto done;</a>
<a name="ln227">			default:</a>
<a name="ln228">				break;</a>
<a name="ln229">			}</a>
<a name="ln230">		}</a>
<a name="ln231"> </a>
<a name="ln232">		if (file_printf(ms, &quot;%s&quot;, code) == -1)</a>
<a name="ln233">			goto done;</a>
<a name="ln234"> </a>
<a name="ln235">		if (subtype) {</a>
<a name="ln236">			if (file_printf(ms, &quot; %s&quot;, subtype) == -1)</a>
<a name="ln237">				goto done;</a>
<a name="ln238">		}</a>
<a name="ln239"> </a>
<a name="ln240">		if (file_printf(ms, &quot; %s&quot;, type) == -1)</a>
<a name="ln241">			goto done;</a>
<a name="ln242"> </a>
<a name="ln243">		if (executable)</a>
<a name="ln244">			if (file_printf(ms, &quot; executable&quot;) == -1)</a>
<a name="ln245">				goto done;</a>
<a name="ln246"> </a>
<a name="ln247">		if (has_long_lines)</a>
<a name="ln248">			if (file_printf(ms, &quot;, with very long lines&quot;) == -1)</a>
<a name="ln249">				goto done;</a>
<a name="ln250"> </a>
<a name="ln251">		/*</a>
<a name="ln252">		 * Only report line terminators if we find one other than LF,</a>
<a name="ln253">		 * or if we find none at all.</a>
<a name="ln254">		 */</a>
<a name="ln255">		if ((n_crlf == 0 &amp;&amp; n_cr == 0 &amp;&amp; n_nel == 0 &amp;&amp; n_lf == 0) ||</a>
<a name="ln256">		    (n_crlf != 0 || n_cr != 0 || n_nel != 0)) {</a>
<a name="ln257">			if (file_printf(ms, &quot;, with&quot;) == -1)</a>
<a name="ln258">				goto done;</a>
<a name="ln259"> </a>
<a name="ln260">			if (n_crlf == 0 &amp;&amp; n_cr == 0 &amp;&amp; n_nel == 0 &amp;&amp; n_lf == 0) {</a>
<a name="ln261">				if (file_printf(ms, &quot; no&quot;) == -1)</a>
<a name="ln262">					goto done;</a>
<a name="ln263">			} else {</a>
<a name="ln264">				if (n_crlf) {</a>
<a name="ln265">					if (file_printf(ms, &quot; CRLF&quot;) == -1)</a>
<a name="ln266">						goto done;</a>
<a name="ln267">					if (n_cr || n_lf || n_nel)</a>
<a name="ln268">						if (file_printf(ms, &quot;,&quot;) == -1)</a>
<a name="ln269">							goto done;</a>
<a name="ln270">				}</a>
<a name="ln271">				if (n_cr) {</a>
<a name="ln272">					if (file_printf(ms, &quot; CR&quot;) == -1)</a>
<a name="ln273">						goto done;</a>
<a name="ln274">					if (n_lf || n_nel)</a>
<a name="ln275">						if (file_printf(ms, &quot;,&quot;) == -1)</a>
<a name="ln276">							goto done;</a>
<a name="ln277">				}</a>
<a name="ln278">				if (n_lf) {</a>
<a name="ln279">					if (file_printf(ms, &quot; LF&quot;) == -1)</a>
<a name="ln280">						goto done;</a>
<a name="ln281">					if (n_nel)</a>
<a name="ln282">						if (file_printf(ms, &quot;,&quot;) == -1)</a>
<a name="ln283">							goto done;</a>
<a name="ln284">				}</a>
<a name="ln285">				if (n_nel)</a>
<a name="ln286">					if (file_printf(ms, &quot; NEL&quot;) == -1)</a>
<a name="ln287">						goto done;</a>
<a name="ln288">			}</a>
<a name="ln289"> </a>
<a name="ln290">			if (file_printf(ms, &quot; line terminators&quot;) == -1)</a>
<a name="ln291">				goto done;</a>
<a name="ln292">		}</a>
<a name="ln293"> </a>
<a name="ln294">		if (has_escapes)</a>
<a name="ln295">			if (file_printf(ms, &quot;, with escape sequences&quot;) == -1)</a>
<a name="ln296">				goto done;</a>
<a name="ln297">		if (has_backspace)</a>
<a name="ln298">			if (file_printf(ms, &quot;, with overstriking&quot;) == -1)</a>
<a name="ln299">				goto done;</a>
<a name="ln300">	}</a>
<a name="ln301">	rv = 1;</a>
<a name="ln302">done:</a>
<a name="ln303">	free(utf8_buf);</a>
<a name="ln304"> </a>
<a name="ln305">	return rv;</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">/*</a>
<a name="ln309"> * Encode Unicode string as UTF-8, returning pointer to character</a>
<a name="ln310"> * after end of string, or NULL if an invalid character is found.</a>
<a name="ln311"> */</a>
<a name="ln312">private unsigned char *</a>
<a name="ln313">encode_utf8(unsigned char *buf, size_t len, unichar *ubuf, size_t ulen)</a>
<a name="ln314">{</a>
<a name="ln315">	size_t i;</a>
<a name="ln316">	unsigned char *end = buf + len;</a>
<a name="ln317"> </a>
<a name="ln318">	for (i = 0; i &lt; ulen; i++) {</a>
<a name="ln319">		if (ubuf[i] &lt;= 0x7f) {</a>
<a name="ln320">			if (end - buf &lt; 1)</a>
<a name="ln321">				return NULL;</a>
<a name="ln322">			*buf++ = (unsigned char)ubuf[i];</a>
<a name="ln323">		} else if (ubuf[i] &lt;= 0x7ff) {</a>
<a name="ln324">			if (end - buf &lt; 2)</a>
<a name="ln325">				return NULL;</a>
<a name="ln326">			*buf++ = (unsigned char)((ubuf[i] &gt;&gt; 6) + 0xc0);</a>
<a name="ln327">			*buf++ = (unsigned char)((ubuf[i] &amp; 0x3f) + 0x80);</a>
<a name="ln328">		} else if (ubuf[i] &lt;= 0xffff) {</a>
<a name="ln329">			if (end - buf &lt; 3)</a>
<a name="ln330">				return NULL;</a>
<a name="ln331">			*buf++ = (unsigned char)((ubuf[i] &gt;&gt; 12) + 0xe0);</a>
<a name="ln332">			*buf++ = (unsigned char)(((ubuf[i] &gt;&gt; 6) &amp; 0x3f) + 0x80);</a>
<a name="ln333">			*buf++ = (unsigned char)((ubuf[i] &amp; 0x3f) + 0x80);</a>
<a name="ln334">		} else if (ubuf[i] &lt;= 0x1fffff) {</a>
<a name="ln335">			if (end - buf &lt; 4)</a>
<a name="ln336">				return NULL;</a>
<a name="ln337">			*buf++ = (unsigned char)((ubuf[i] &gt;&gt; 18) + 0xf0);</a>
<a name="ln338">			*buf++ = (unsigned char)(((ubuf[i] &gt;&gt; 12) &amp; 0x3f) + 0x80);</a>
<a name="ln339">			*buf++ = (unsigned char)(((ubuf[i] &gt;&gt;  6) &amp; 0x3f) + 0x80);</a>
<a name="ln340">			*buf++ = (unsigned char)((ubuf[i] &amp; 0x3f) + 0x80);</a>
<a name="ln341">		} else if (ubuf[i] &lt;= 0x3ffffff) {</a>
<a name="ln342">			if (end - buf &lt; 5)</a>
<a name="ln343">				return NULL;</a>
<a name="ln344">			*buf++ = (unsigned char)((ubuf[i] &gt;&gt; 24) + 0xf8);</a>
<a name="ln345">			*buf++ = (unsigned char)(((ubuf[i] &gt;&gt; 18) &amp; 0x3f) + 0x80);</a>
<a name="ln346">			*buf++ = (unsigned char)(((ubuf[i] &gt;&gt; 12) &amp; 0x3f) + 0x80);</a>
<a name="ln347">			*buf++ = (unsigned char)(((ubuf[i] &gt;&gt;  6) &amp; 0x3f) + 0x80);</a>
<a name="ln348">			*buf++ = (unsigned char)((ubuf[i] &amp; 0x3f) + 0x80);</a>
<a name="ln349">		} else if (ubuf[i] &lt;= 0x7fffffff) {</a>
<a name="ln350">			if (end - buf &lt; 6)</a>
<a name="ln351">				return NULL;</a>
<a name="ln352">			*buf++ = (unsigned char)((ubuf[i] &gt;&gt; 30) + 0xfc);</a>
<a name="ln353">			*buf++ = (unsigned char)(((ubuf[i] &gt;&gt; 24) &amp; 0x3f) + 0x80);</a>
<a name="ln354">			*buf++ = (unsigned char)(((ubuf[i] &gt;&gt; 18) &amp; 0x3f) + 0x80);</a>
<a name="ln355">			*buf++ = (unsigned char)(((ubuf[i] &gt;&gt; 12) &amp; 0x3f) + 0x80);</a>
<a name="ln356">			*buf++ = (unsigned char)(((ubuf[i] &gt;&gt;  6) &amp; 0x3f) + 0x80);</a>
<a name="ln357">			*buf++ = (unsigned char)((ubuf[i] &amp; 0x3f) + 0x80);</a>
<a name="ln358">		} else /* Invalid character */</a>
<a name="ln359">			return NULL;</a>
<a name="ln360">	}</a>
<a name="ln361"> </a>
<a name="ln362">	return buf;</a>
<a name="ln363">}</a>
</code></pre>
<div class="balloon" rel="181"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v536/" target="_blank">V536</a> Be advised that the utilized constant value is represented by an octal form. Oct: '\033', Dec: 27.</p></div>
<div class="balloon" rel="200"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'subtype_mime' is always false.</p></div>
<div class="balloon" rel="235"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'subtype' is always false.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>